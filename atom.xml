<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anduril</title>
  
  <subtitle>一枚鸡蛋狂热者的疯言疯语</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://anduril.cn/"/>
  <updated>2018-05-06T13:23:39.956Z</updated>
  <id>http://anduril.cn/</id>
  
  <author>
    <name>Hejin Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>0x02.犀牛书札记(ch4-6)</title>
    <link href="http://anduril.cn/2018/05/06/js-6th-notes-ch4-6/"/>
    <id>http://anduril.cn/2018/05/06/js-6th-notes-ch4-6/</id>
    <published>2018-05-06T13:09:39.000Z</published>
    <updated>2018-05-06T13:23:39.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ch4-表达式（expression）和运算符（operator）"><a href="#ch4-表达式（expression）和运算符（operator）" class="headerlink" title="ch4 表达式（expression）和运算符（operator）"></a>ch4 表达式（expression）和运算符（operator）</h1><p><strong>原始表达式（primary expression）</strong><br>表达式最小单位，包含常量、直接量（直接在程序中出现的常数值）、关键字、变量。</p><p>数组直接量中的列表逗号之间的元素可以省略，省略的空位会填充undefined。列表结尾处可以留下单个逗号，不会创建一个新的值undefined元素。</p><p>函数定义表达式可称为函数直接量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x*x; &#125;</div></pre></td></tr></table></figure></p><p><strong>属性访问表达式</strong>  会首先计算表达式，如果结果是null或者undefined，就抛出一个类型错误异常。expression结果不是对象或者数组，会将其转换为对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">expression.identifier</div><div class="line"><span class="comment">//属性名称是一个保留字或者包含空格和标点符号，或是一个数字（对于数组来说）；或属性名是通过运算得出的值而不是固定的值的时候</span></div><div class="line">expression[expression]</div></pre></td></tr></table></figure><p><strong>调用表达式（invocation expression）</strong><br>调用（或者执行）函数或方法的语法。</p><p>如果表达式是一个属性访问表达式，那么调用称做“方法调用”（method invocation）。<br>在方法调用中，执行函数体的时候，作为属性访问主题的对象和数组便是其调用方法内this的指向。这种特性使得在面向对象编程范例中，函数（其OO名称为“方法”）可以调用其宿主对象。</p><p><strong>对象创建表达式（object creation expression）</strong><br>创建一个对象并调用一个函数（这个函数称做构造函数）初始化新对象的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果不需要传入任何参数给构造函数的话，圆括号是可以省略掉的</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Date</span></div></pre></td></tr></table></figure><h2 id="4-7-运算符"><a href="#4-7-运算符" class="headerlink" title="4.7 运算符"></a>4.7 运算符</h2><p>左值 lvalue（变量、数组元素或对象属性）  表达式只能出现在赋值运算符的左侧。 自定义的函数不能返回左值。</p><p>属性访问表达式和调用表达式的优先级最高。</p><h2 id="4-8-算术表达式"><a href="#4-8-算术表达式" class="headerlink" title="4.8 算术表达式"></a>4.8 算术表达式</h2><p>所有那些无法转换为数字的操作数都转换为 NaN 值。 如果操作数（或者转换 结果）是NaN值， 算术运算的结果也是NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">5</span>/<span class="number">2</span>  <span class="comment">//=&gt;2.5  所有数字都是浮点类型</span></div><div class="line">n/<span class="number">0</span>  <span class="comment">// n不等于0   =&gt; Infinity or -Infinity</span></div><div class="line"><span class="number">0</span>/<span class="number">0</span>  <span class="comment">// NaN</span></div><div class="line"></div><div class="line"><span class="comment">// % 结果跟被除数符号保持一致</span></div><div class="line"><span class="number">5</span>%<span class="number">2</span>   <span class="comment">//=&gt;1</span></div><div class="line"><span class="number">5</span>%<span class="number">-2</span>  <span class="comment">//=&gt;1</span></div><div class="line"><span class="number">-5</span>%<span class="number">2</span>  <span class="comment">//=&gt;-1</span></div><div class="line"></div><div class="line"><span class="comment">//浮点数求余</span></div><div class="line"><span class="number">6.5</span>%<span class="number">2.1</span> <span class="comment">//=&gt;0.19999999999999973</span></div></pre></td></tr></table></figure><h3 id="4-8-1-运算符"><a href="#4-8-1-运算符" class="headerlink" title="4.8.1 +运算符"></a>4.8.1 +运算符</h3><p>如果两个操作数都不是类字符串（string-like）的，将进行算符加减法。</p><ul><li>如果其中一个操作数是对象，则对象会遵循对象到原始值的转换规则转换为原始类值：日期对象通过toString()方法执行转换，其他对象则通过valueOf()方法执行转换（如果valueOf()方法返回一个原始值的话）。由于多数对象都不具备可用的valueOf()方法，因此它们会通过toString()方法来执行转换。</li><li>在进行了对象到原始值的转换后，如果其中一个操作数是字符串的话，另一个操作数也会转换为字符串，然后进行字符串连接。</li><li>否则，两个操作数都将转换为数字（或者NaN），然后进行加法操作。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="literal">true</span>+<span class="literal">true</span>  <span class="comment">// =&gt; 2 布尔数值转换成数字</span></div><div class="line"><span class="number">2</span>+<span class="literal">null</span> <span class="comment">// =&gt; 2 ：null 转换为0后做加法</span></div><div class="line"><span class="number">2</span>+<span class="literal">undefined</span>   <span class="comment">//=&gt;NaN ： undefined转换为NaN做加法</span></div></pre></td></tr></table></figure><h3 id="4-8-3-位运算符"><a href="#4-8-3-位运算符" class="headerlink" title="4.8.3 位运算符"></a>4.8.3 位运算符</h3><p>位运算符将NaN  Infinity   -Infinity 转换为0</p><h2 id="4-9-关系表达式"><a href="#4-9-关系表达式" class="headerlink" title="4.9 关系表达式"></a>4.9 关系表达式</h2><p>===  严格相等运算符（strict equality） 恒等运算符（identity operator）<br>==  相等运算符（equality operator）  相等允许进行类型转换</p><p> <strong> ===</strong> </p><ul><li>两值 为null 或undefined，不相等。</li><li>如果其中一个NaN或者都是NaN,则不相等。 x !== x 为true  x为NaN</li><li>0===-0</li></ul><p> <strong>==</strong><br>两个操作数类型相等，和严格相等比较规则一样。<br>两个操作数类型不同，会进行类型转换</p><ul><li>null == undefined</li><li>一个数字 一个字符串，先讲字符串转换为数字，然后比较</li><li>true 转化为 1   false转换为 0</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//其他不同类型之间的比较均不相等</span></div><div class="line"><span class="string">"1"</span>==<span class="literal">true</span></div></pre></td></tr></table></figure><h3 id="4-9-2-比较运算符"><a href="#4-9-2-比较运算符" class="headerlink" title="4.9.2 比较运算符"></a>4.9.2 比较运算符</h3><ul><li>如果操作数为对象，那么这个对象将转换为原始值：如果valueOf()返回一个原始值，那么直接使用这个原始值。否则，使用toString()的转换结果进行比较操作。</li><li>在对象转换为原始值之后，如果两个操作数都是字符串，那么将依照字母表的顺序对两个字符串进行比较，这里提到的“字母表顺序”是指组成这个字符串的16位Unicode字符的索引顺序。</li><li>在对象转换为原始值之后，如果至少有一个操作数不是字符串，那么两个操作数都将转换为数字进行数值比较。0和-0是相等的。Infinity比其他任何数字都大（除了Infinity本身），-Infinity比其他任何数字都小（除了它自身）。如果其中一个操作数是（或转换后是）NaN，那么比较操作符总是返回false.</li></ul><h3 id="4-9-3-in运算符"><a href="#4-9-3-in运算符" class="headerlink" title="4.9.3 in运算符"></a>4.9.3 in运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果右侧的对象拥有一个名为左操作数值的属性名，返回true</span></div><div class="line"><span class="keyword">var</span> data=[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];</div><div class="line"><span class="string">"0"</span> <span class="keyword">in</span> data  <span class="comment">// =&gt; true  数组包含元素"0</span></div><div class="line"><span class="number">1</span> <span class="keyword">in</span> data   <span class="comment">// =&gt; true 数字转换为字符串</span></div><div class="line"><span class="number">3</span> <span class="keyword">in</span> data   <span class="comment">// =&gt; false 没有索引为3的元素</span></div></pre></td></tr></table></figure><p>原型链 prototype chain  作为JavaScript的继承机制。</p><h3 id="4-9-4-instanceof运算符"><a href="#4-9-4-instanceof运算符" class="headerlink" title="4.9.4 instanceof运算符"></a>4.9.4 instanceof运算符</h3><p>判断是一个对象是否为类的实例。<br>原型链 prototype chain  作为JavaScript的继承机制。</p><h2 id="4-10-逻辑表达式"><a href="#4-10-逻辑表达式" class="headerlink" title="4.10 逻辑表达式"></a>4.10 逻辑表达式</h2><p>求X的等价布尔值  =&gt;  !!X</p><h2 id="4-11-赋值表达式"><a href="#4-11-赋值表达式" class="headerlink" title="4.11 赋值表达式"></a>4.11 赋值表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a  op= b 等价于 a=a op b  </span></div><div class="line"><span class="comment">//后者 a计算了两次，如果a包含具有副作用的表达式（函数调用、赋值）时，两者不等价。</span></div><div class="line"><span class="keyword">var</span>  data = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]; <span class="keyword">var</span> i=<span class="number">0</span>;</div><div class="line"><span class="comment">//存在副作用 不等价</span></div><div class="line">data[i++] *= <span class="number">2</span>;</div><div class="line">data[i++]  = data[i++]*<span class="number">2</span>;   <span class="comment">//先计算左值 data[0]=data[1]*2</span></div></pre></td></tr></table></figure><h2 id="4-12-eval"><a href="#4-12-eval" class="headerlink" title="4.12 eval()"></a>4.12 eval()</h2><p>只有一个参数。</p><ul><li>如果传入的参数不是字符串，它直接返回这个参数。</li><li>如果参数是字符串，它会把字符串当成JavaScript代码进行编译（parse），如果编译失败则抛出一个语法错误（SyntaxError）异常。</li><li>编译成功，开始执行这段代码，并返回字符串的最后一个表达式或语句的值，如果最后一个表达式或语句没有值，则最终返回undefined.</li><li>如果字符串抛出一个异常，这个异常将把该调用传递给eval()。</li></ul><p>eval()使用了调用它的变量作用域环境。它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(temp)   <span class="comment">// temp is not defined</span></div><div class="line"><span class="built_in">eval</span>(<span class="string">"temp=1;"</span>)     <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(temp);  <span class="comment">// 1</span></div></pre></td></tr></table></figure><p>eval的字符串执行时的上下文环境和调用函数的上下文环境是一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="built_in">eval</span>(a);&#125;;</div><div class="line"><span class="comment">// 异常 Illegal return statement  </span></div><div class="line"><span class="comment">// return 语句只能放在function中</span></div><div class="line">foo(<span class="string">"return;"</span>);</div></pre></td></tr></table></figure><p>直接使用非限定的”eval”名称来调用eval()函数，称为“直接eval”（direct eval） 。ES5直接调用eval()时，它总是在调用它的上下文作用域内执行。其他的间接调用则使用全局对象作为其上下文作用域，并且无法读、写、定义局部变量和函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> geval = <span class="built_in">eval</span>; <span class="comment">// 使用别名调用eval将是全局eval</span></div><div class="line"><span class="keyword">var</span> x = <span class="string">"global"</span>,    y = <span class="string">"global"</span>; <span class="comment">// 两个全局变量</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 函数内执行的是局部eval    </span></div><div class="line"><span class="keyword">var</span> x = <span class="string">"local"</span>; <span class="comment">// 定义局部变量    </span></div><div class="line"><span class="built_in">eval</span>(<span class="string">"x += 'changed';"</span>); <span class="comment">// 直接eval更改了局部变量的值    </span></div><div class="line"><span class="keyword">return</span> x; <span class="comment">// 返回更改后的局部变量</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 这个函数内执行了全局eval    </span></div><div class="line"><span class="keyword">var</span> y = <span class="string">"local"</span>; <span class="comment">// 定义局部变量    </span></div><div class="line">geval(<span class="string">"y += 'changed';"</span>); <span class="comment">// 间接调用改变了全局变量的值    </span></div><div class="line"><span class="keyword">return</span> y; <span class="comment">// 返回未更改的局部变量</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(f(), x); <span class="comment">// 更改了局部变量：输出"localchanged global":</span></div><div class="line"><span class="built_in">console</span>.log(g(), y); <span class="comment">// 更改了全局变量：输出"local globalchanged":</span></div></pre></td></tr></table></figure><h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><p>typeof x == typeof(x)  主要区分原始值和对象值</p><table><thead><tr><th>x</th><th>typeof x</th></tr></thead><tbody><tr><td>undefined</td><td>“undefined”</td></tr><tr><td>null</td><td>“object”</td></tr><tr><td>true或false</td><td>“boolean”</td></tr><tr><td>任意数字或NaN</td><td>“number”</td></tr><tr><td>任意字符串</td><td>“string”</td></tr><tr><td>任意函数</td><td>“function”</td></tr><tr><td>任意内置对象（非函数）</td><td>“object”</td></tr><tr><td>任意宿主对象</td><td>由编译器各自实现的字符串，但不是”undefined”、”boolean”、”num-ber”或”string”</td></tr></tbody></table><p>函数 &amp; “可执行的对象”（callable object）</p><ul><li>所有的函数都是可执行的（callable），但是对象也有可能是可执行的，可以像调用函数一样调用它，但它并不是一个真正的函数。</li><li>ECMAScript 5规范则扩充至所有可执行对象，包括内置对象（native object）和宿主对象（hosTobject），所有可执行对象进行typeof运算都将返回“function”。</li><li>大多数浏览器厂商也将JavaScript的原生函数对象（native function object）当成它们的宿主对象的方法来使用。</li></ul><h2 id="delete运算符"><a href="#delete运算符" class="headerlink" title="delete运算符"></a>delete运算符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 定义一个数组</span></div><div class="line"><span class="keyword">delete</span> a[<span class="number">2</span>]; <span class="comment">// 删除最后一个数组元素</span></div><div class="line"><span class="number">2</span> <span class="keyword">in</span> a; <span class="comment">// =&gt; false:元素2在数组中已经不存在了</span></div><div class="line">a.length <span class="comment">// =&gt; 3:注意，数组长度并没有改变，尽管上一行代码删除了这个元素，但删除操作留下了一个“洞”，实际上并没有修改数组的长度，因此 a数组的长度仍然是 3</span></div></pre></td></tr></table></figure><ul><li>操作数不是左值，那么delete将不进行任何操作同时返回true</li><li>通过var语句声明的变量不能删除。</li><li>通过function语句定义的函数和函数参数也不能删除。</li></ul><h1 id="ch5-语句（statement）"><a href="#ch5-语句（statement）" class="headerlink" title="ch5 语句（statement）"></a>ch5 语句（statement）</h1><p>函数定义不能出现在if语句、while循环或其他任何语句中。       </p><p><strong>函数定义表达式</strong><br>函数定义语句中的函数被显示地提前到脚本或函数的顶部<br><strong>函数声明语句</strong><br>函数名称和函数体均提前：脚本中的所有函数和函数中所有嵌套的函数都会在当前上下文中其他代码之前声明。<em>可以在声明一个JavaScript函数之前调用它。</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数定义表达式 </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">x1</span>(<span class="params"></span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//x2();     //function is not defined</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> x2);    <span class="comment">//undefined</span></div><div class="line">    <span class="built_in">console</span>.log(x2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);  <span class="comment">//false</span></div><div class="line">    <span class="keyword">var</span> x2=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">x1();</div><div class="line"></div><div class="line"><span class="comment">// 函数声明语</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> t=<span class="number">2</span>;</div><div class="line">    t=y(t);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params">param</span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>  param*<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>  t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> t=<span class="number">2</span>;</div><div class="line">    t=y(t);</div><div class="line">    <span class="keyword">return</span>  t;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">y</span>(<span class="params">param</span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>  param*<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>switch  按照“===”运算符比较case子句中的表达式是否和expression的值相同。   </p><p><strong>for/in</strong><br>只有“可枚举”（enumerable）的属性才会遍历到。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JavaScript解释器首先计算object表达式。</span></div><div class="line"><span class="comment">//如果表达式为null或者undefined，JavaScirpt解释器将会跳过循环并执行后续的代码。</span></div><div class="line"><span class="comment">//如果表达式等于一个原始值，这个原始值将会转换为与之对应的包装对象（wrapper object）</span></div><div class="line"><span class="keyword">for</span> (variable <span class="keyword">in</span> object)   </div><div class="line">    statement</div><div class="line">    </div><div class="line"><span class="comment">//中variable的值可以当做赋值表达式的左值    </span></div><div class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>, <span class="attr">z</span>:<span class="number">3</span>&#125;;</div><div class="line"><span class="keyword">var</span> a = [],    </div><div class="line">    i = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (a[i++] <span class="keyword">in</span> o) <span class="comment">/* empty */</span>;    <span class="comment">//a =&gt; ["x", "y", "z"]</span></div></pre></td></tr></table></figure></p><p>如果没有return语句，则函数调用调用表达式的结果是undefined。return语句单独使用,函数调用程序返回undefined。</p><p>catch 从句参数具有块级作用域效果。</p><p><strong>with语句</strong><br>with语句用于临时扩展作用域链(在严格模式中是禁止使用with语句的，并且在非严格模式里也是不推荐使用with语句的)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将object添加到作用域链的头部，然后执行statement，最后把作用域链恢复到原始状态 </span></div><div class="line"><span class="keyword">with</span>(object)</div><div class="line">statement</div><div class="line"></div><div class="line"><span class="comment">//对象嵌套层次很深的时候通常会使用with语句来简化代码编写</span></div><div class="line"><span class="comment">//document.forms[0].address.value</span></div><div class="line"><span class="keyword">with</span>(<span class="built_in">document</span>.forms[<span class="number">0</span>]) &#123;    </div><div class="line">    <span class="comment">// 直接访问表单元素，例如:    </span></div><div class="line">    name.value = <span class="string">""</span>;    </div><div class="line">    address.value = <span class="string">""</span>;    </div><div class="line">    email.value = <span class="string">""</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//等价代码</span></div><div class="line"><span class="keyword">var</span> f = <span class="built_in">document</span>.forms[<span class="number">0</span>];</div><div class="line">f.name.value = <span class="string">""</span>;</div><div class="line">f.address.value = <span class="string">""</span>;</div><div class="line">f.email.value = <span class="string">""</span>;</div></pre></td></tr></table></figure><p>with语句提供了一种读取对象的属性的快捷方式，但它并不能创建属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果对象o有一个属性x，那么这行代码给这个属性赋值为1。</span></div><div class="line"><span class="comment">//如果对象o没有定义属性x，它给一个局部变量或者全局变量x赋值，或者创建全局对象的一个新属性。</span></div><div class="line"><span class="keyword">with</span>(o) x = <span class="number">1</span>;</div></pre></td></tr></table></figure><p><strong>debugger语句</strong><br>这条语句用来产生一个断点（breakpoint）</p><p><strong>“use strict”</strong><br>ES5引入的指令 说明（脚本或函数中）后续的代码将会解析为严格代码（strict code）。</p><ul><li>指令和普通的语句之间的区别 指令不包含任何语言的关键字，仅仅是一个包含一个特殊字符串直接量的表达式（可以是使用单引号也可以使用双引号）。</li><li>指令只能出现在脚本代码的开始或者函数体的开始、任何实体语句之前。但它不必一定出现在脚本的首行或函数体内的首行。</li></ul><p><strong>严格模式</strong></p><ul><li>禁止使用with语句</li><li>在严格模式中，所有的变量都要先声明，如果给一个未声明的变量、函数、函数参数、catch从句参数或全局对象的属性赋值，将会抛出一个引用错误异常（在非严格模式中，这种隐式声明的全局变量的方法是给全局对象新添加一个新属性）。   </li><li>在严格模式中，调用的函数（不是方法）中的一个this值是undefined。（在非严格模式中，调用的函数中的this值总是全局对象）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hasStrictMode = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="string">"use strict"</span>; <span class="keyword">return</span> <span class="keyword">this</span>===<span class="literal">undefined</span>&#125;());   <span class="comment">//判断JavaScript实现是否支持严格模式</span></div></pre></td></tr></table></figure><ul><li>在严格模式中，当通过call()或apply()来调用函数时，其中的this值就是通过call()或apply()传入的第一个参数（在非严格模式中，null和undefined值被全局对象和转换为对象的非对象值所代替）。  </li><li>在严格模式中，给只读属性赋值和给不可扩展的对象创建新成员都将抛出一个类型错误异常（在非严格模式中，这些操作只是简单地操作失败，不会报错）。</li><li>在严格模式中，传入eval()的代码不能在调用程序所在的上下文中声明变量或定义函数，而在非严格模式中是可以这样做的。相反，变量和函数的定义是在eval()创建的新作用域中，这个作用域在eval()返回时就弃用了。</li><li>严格模式中，函数里的arguments对象拥有传入函数值的静态副本。在非严格模式中，arguments对象具有“魔术般”的行为，arguments里的数组元素和函数参数都是指向同一个值的引用</li><li>在严格模式中，当delete运算符后跟随非法的标识符（比如变量、函数、函数参数）时，将会抛出一个语法错误异常（在非严格模式中，这种delete表达式什么也没做，并返回false）。 </li><li>在严格模式中，试图删除一个不可配置的属性将抛出一个类型错误异常（在非严格模式中，delete表达式操作失败，并返回false）。  </li><li>在严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误（在非严格模式中不会报错）。   </li><li>在严格模式中，函数声明中存在两个或多个同名的参数将产生一个语法错误（在非严格模式中不会报错）。</li><li>在严格模式中是不允许使用八进制整数直接量（以0为前缀，而不是0x为前缀）的（在非严格模式中某些实现是允许八进制整数直接量的）。  </li><li>在严格模式中，标识符eval和arguments当做关键字，它们的值是不能更改的。不能给这些标识符赋值，也不能把它们声明为变量、用做函数名、用做函数参数或用做catch块的标识符。  </li><li>在严格模式中限制了对调用栈的检测能力，在严格模式的函数中，arguments.caller和arguments.callee都会抛出一个类型错误异常。严格模式的函数同样具有caller和argu-ments属性，当访问这两个属性时将抛出类型错误异常。</li></ul><h1 id="ch6-对象"><a href="#ch6-对象" class="headerlink" title="ch6 对象"></a>ch6 对象</h1><p>“原型式继承”（prototypal inheritance）是JavaScript的核心特征。<br>对象最常见的用法是创建（create）、设置（set）、查找（query）、删除（delete）、检测（test）和枚举（enumerate）它的属性。     </p><p>属性名可以包含空字符串在内的任意字符串。</p><p>“属性特性”（property attribute）</p><ul><li>可写（writable attribute），表明是否可以设置该属性的值。   </li><li>可枚举（enumerable attribute），表明是否可以通过for/in循环返回该属性。   </li><li>可配置（configurable attribute），表明是否可以删除或修改该属性。</li></ul><p>对象特性（object attribute）</p><ul><li>对象的原型（prototype）指向另外一个对象，本对象的属性继承自它的原型对象。 </li><li>对象的类（class）是一个标识对象类型的字符串。  </li><li>对象的扩展标记（extensible flag）指明了（在ES5中）是否可以向该对象添加新属性。</li></ul><p>相关术语</p><ul><li>内置对象（native object）是由ECMAScript规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。   </li><li>宿主对象（hosTobject）是由JavaScript解释器所嵌入的宿主环境（比如Web浏览器）定义的。客户端JavaScript中表示网页结构的HTMLElement对象均是宿主对象。既然宿主环境定义的方法可以当成普通的JavaScript函数对象，那么宿主对象也可以当成内置对象。 </li><li>自定义对象（user-defined object）是由运行中的JavaScript代码创建的对象。</li><li>自有属性（own property）是直接在对象中定义的属性。 </li><li>继承属性（inherited property）是在对象的原型对象中定义的属性。</li></ul><h2 id="6-1创建对象（create）"><a href="#6-1创建对象（create）" class="headerlink" title="6.1创建对象（create）"></a>6.1创建对象（create）</h2><p>以通过对象直接量、关键字new和（ES5中的）Object.create()函数来创建对象</p><p><strong>对象直接量</strong><br>对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。如果值存在计算，那么多次调用中属性值可能不同。<br>最后一个属性后逗号将忽略。</p><p><strong>关键字new</strong><br>new 后跟跟随一个构造函数（constructor），初始化一个新创建的对象。  </p><p><strong>原型链”（prototype chain）</strong></p><ul><li>所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过Object.prototype获得对原型对象的引用。</li><li>通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性的值。也继承自Object.prototype。通过new Array()创建的对象的原型就是Array.prototype，通过new Date()创建的对象的原型就是Date.prototype。</li><li>Object.prototype没有原型的对象。它不继承任何属性。<br> 其他原型对象都是普通对象，普通对象都具有原型。</li><li>所有的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自Object.prototype的原型。例如，Date.prototype的属性继承自Object.prototype，因此由new Date()创建的Date对象的属性同时继承自Date.prototype和Object.prototype。</li><li>null没原型</li></ul><p><strong>Object.create()</strong><br>Object.create()是一个静态函数，而不是提供给某个对象调用的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o1 = <span class="built_in">Object</span>.create(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;); <span class="comment">// o1继承了属性x和y</span></div><div class="line"></div><div class="line"><span class="comment">//创建一个没有原型的新对象</span></div><div class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>); <span class="comment">//o2不继承任何属性和方法</span></div><div class="line"></div><div class="line"><span class="comment">//创建一个普通的空对象</span></div><div class="line"><span class="keyword">var</span> o3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype); <span class="comment">//o3和&#123;&#125;和new Object()一样</span></div></pre></td></tr></table></figure><p>inherit()防止库函数无意间修不受控制的对象。修改继承对象的属性值，只会影响继承对象自身。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// inherit() 返回了一个继承自原型对象p的属性的新对象</span></div><div class="line"><span class="comment">// 这里使用ECMAScript 5中的Object.create()函数（如果存在的话）</span></div><div class="line"><span class="comment">// 如果不存在Object.create()，则退化使用其他方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">p</span>) </span>&#123;    </div><div class="line">    <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>(); <span class="comment">// p是一个对象，但不能是null   </span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.create) <span class="comment">// 如果Object.create()存在      </span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(p); <span class="comment">// 直接使用它   </span></div><div class="line">    <span class="keyword">var</span> t = <span class="keyword">typeof</span> p; <span class="comment">// 否则进行进一步检测   </span></div><div class="line">    <span class="keyword">if</span> (t !== <span class="string">"object"</span> &amp;&amp; t !== <span class="string">"function"</span>) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();  </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 定义一个空构造函数   </span></div><div class="line">    f.prototype = p; <span class="comment">//将其原型属性设置为p   </span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> f(); <span class="comment">//使用f()创建p的继承对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="6-2-属性的查询和设置"><a href="#6-2-属性的查询和设置" class="headerlink" title="6.2 属性的查询和设置"></a>6.2 属性的查询和设置</h2><p>数组元素是通过字符串索引而不是数字索引。这种数组就是我们所说的关联数组（associative array），也称做散列、映射或字典（dictionary）。JavaScript对象都是关联数组。</p><p>“自有属性”（own property）  只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关   (override)</p><ul><li>属性赋值操作首先检查原型链，以此判定是否允许赋值操作。</li><li>如果允许属性赋值操作，它也总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链。</li></ul><p>null和undefined值都没有属性，查询这些值的属性会报错、设置属性也会报类型错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> len = book &amp;&amp;book.subtitle &amp;&amp;book.subtitle.length;</div></pre></td></tr></table></figure><p>对象设置属性失败场景</p><ul><li>o中的属性p是只读的：不能给只读属性重新赋值（defineProperty()方法中有一个例外，可以对可配置的只读属性重新赋值）。</li><li>o中的属性p是继承属性，且它是只读的：不能通过同名自有属性覆盖只读的继承属性。   </li><li>o中不存在自有属性p：o没有使用setter方法继承属性p，并且o的可扩展性（extensible attribute）是false。如果o中不存在p，而且没有setter方法可供调用，则p一定会添加至o中。但如果o不是可扩展的，那么在o中不能定义新属性。</li></ul><h2 id="6-3-删除"><a href="#6-3-删除" class="headerlink" title="6.3 删除"></a>6.3 删除</h2><p>delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性<br>delete运算符只能删除自有属性，不能删除继承属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a=&#123;<span class="attr">p</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;&#125;;b=a.p;<span class="keyword">delete</span> a.p;</div><div class="line">b.x   <span class="comment">// =&gt;  1   已删除的引用依然存在</span></div></pre></td></tr></table></figure></p><p>当delete表达式删除成功或没有任何副作用（比如删除不存在的属性）时，它返回true。如果delete后不是一个属性访问表达式，delete同样返回true：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;; <span class="comment">// o有一个属性x，并继承属性toString</span></div><div class="line"><span class="keyword">delete</span> o.x; <span class="comment">// 删除x，返回true</span></div><div class="line"><span class="keyword">delete</span> o.x; <span class="comment">// 什么都没做（x已经不存在了），返回true</span></div><div class="line"><span class="keyword">delete</span> o.toString; <span class="comment">// 什么也没做（toString是继承来的），返回true</span></div><div class="line"><span class="keyword">delete</span> <span class="number">1</span>; <span class="comment">// 无意义，返回true</span></div></pre></td></tr></table></figure><p>delete不能删除那些可配置性为false的属性，例如通过变量声明、函数声明创建的全局对象属性。<br>当在非严格模式中删除全局对象的可配值属性时，可以省略对全局对象的引用，直接在delete操作符后跟随要删除的属性名即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.x = <span class="number">1</span>; <span class="comment">// 创建一个可配置的全局属性（没有用var）</span></div><div class="line"><span class="keyword">delete</span> x; <span class="comment">// 将它删除</span></div></pre></td></tr></table></figure></p><h2 id="6-4-检测属性"><a href="#6-4-检测属性" class="headerlink" title="6.4 检测属性"></a>6.4 检测属性</h2><p>判断某个属性是否存在于某个对象中        </p><ul><li>in运算符   如果对象的自有属性或继承属性中包含这个属性则返回true：</li><li>hasOwnPreperty()   是否是对象的自有属性。对于继承属性它将返回false：</li><li>propertyIsEnumerable()  只有检测到是自有属性且这个属性的可枚举性（enumerable attribute）为true时它才返回true。通常由JavaScript代码创建的属性都是可枚举的</li><li>通过属性查询   使用“!==”判断一个属性是否是undefined</li></ul><p><em>in可以区分不存在的属性和存在但值为undefined的属性</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="literal">undefined</span> &#125; <span class="comment">// 属性被显式赋值为undefined</span></div><div class="line">o.x !== <span class="literal">undefined</span> <span class="comment">// false：属性存在，但值为undefined</span></div><div class="line">o.y !== <span class="literal">undefined</span> <span class="comment">// false：属性不存在</span></div><div class="line"><span class="string">"x"</span> <span class="keyword">in</span> o <span class="comment">// true：属性存在</span></div><div class="line"><span class="string">"y"</span> <span class="keyword">in</span> o <span class="comment">// false：属性不存在</span></div><div class="line"><span class="keyword">delete</span> o.x; <span class="comment">// 删除了属性x</span></div><div class="line"><span class="string">"x"</span> <span class="keyword">in</span> o <span class="comment">// false：属性不再存在</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 如果o中含有属性x，且x的值不是null或undefined，o.x乘以2.</span></div><div class="line"><span class="keyword">if</span> (o.x != <span class="literal">null</span>) o.x *= <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">// 如果o中含有属性x，且x的值不能转换为false，o.x乘以2.</span></div><div class="line"><span class="comment">// 如果x是undefined、null、false、" " 、0或NaN，则它保持不变</span></div><div class="line"><span class="keyword">if</span> (o.x) o.x *= <span class="number">2</span>;</div></pre></td></tr></table></figure></p><h2 id="6-5-枚举属性"><a href="#6-5-枚举属性" class="headerlink" title="6.5 枚举属性"></a>6.5 枚举属性</h2><p>for/in循环可以在循环体中遍历对象中所有可枚举的属性（包括自有属性和继承的属性）。<br>对象继承的内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;    </div><div class="line">    <span class="keyword">if</span> (!o.hasOwnProperty(p)) <span class="keyword">continue</span>; <span class="comment">// 跳过继承的属性</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (p <span class="keyword">in</span> o) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o[p] === <span class="string">"function"</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Object.keys()，它返回一个数组，这个数组由对象中可枚举的自有属性的名称组成。<br>Object.getOwnPropertyNames()，返回对象的所有自有属性的名称,包括不可枚举.</p><h2 id="6-6-getter-setter"><a href="#6-6-getter-setter" class="headerlink" title="6.6 getter setter"></a>6.6 getter setter</h2><p>由getter和setter定义的属性称做“存取器属性”（accessor property），它不同于“数据属性”（data property），数据属性只有一个简单的值。<br>存取器属性不具有可写性（writable attribute).如果它只有setter方法，那么它是一个只写属性，读取只写属性总是返回undefined。存取器属性是可以继承的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回随机数的存取器属性 例如，表达式"random.octet"产生一个随机数</span></div><div class="line"><span class="comment">// 每次产生的随机数都在0～255之间</span></div><div class="line"><span class="keyword">var</span> random = &#123;</div><div class="line">    get octet() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">256</span>);</div><div class="line">    &#125;,</div><div class="line">    get uint16() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">65536</span>);</div><div class="line">    &#125;,</div><div class="line">    get int16() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">65536</span>) - <span class="number">32768</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="6-7-属性的特性"><a href="#6-7-属性的特性" class="headerlink" title="6.7 属性的特性"></a>6.7 属性的特性</h2><ul><li>给原型对象添加方法，并将它们设置成不可枚举的，这让它们看起来更像内置方法。 </li><li>给对象定义不能修改或删除的属性，借此“锁定”这个对象。</li></ul><p>数据属性的4个特性分别是它的值（value）、可写性（writable）、可枚举性（enumerable）和可配置性（configurable）。<br>存取器属性的4个特性是读取（get）、写入（set）、可枚举性和可配置性。</p><p>“属性描述符”（property descriptor）的对象</p><ul><li>数据属性的描述符对象的属性有value、writable、enumerable和configurable。</li><li>存取器属性的描述符对象的属性有get、set、enumerable和configurable。</li><li>其中writable、enumerable和configurable都是布尔值，get属性和set属性是函数值</li></ul><p>Object.getOwnPropertyDescriptor()  获得自有属性的描述符。对于继承属性和不存在的属性，返回undefined。<br>要想获得继承属性的特性，需要遍历原型链 Object.getPrototypeOf()。</p><p>设置属性的特性 Object.defineProperty()  Object.defineProperties()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//新创建的属性来说，默认的特性值是false或undefined</span></div><div class="line"><span class="keyword">var</span> o = &#123;&#125;;</div><div class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">'x'</span>,&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;);</div><div class="line"><span class="comment">//&#123;value: 1, writable: false, enumerable: false, configurable: false&#125;   </span></div><div class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o, <span class="string">'x'</span>);</div></pre></td></tr></table></figure><ul><li>如果对象是不可扩展的，则可以编辑已有的自有属性，但不能给它添加新属性。 </li><li>如果属性是不可配置的，则不能修改它的可配置性和可枚举性。 </li><li>如果存取器属性是不可配置的，则不能修改其getter和setter方法，也不能将它转换为数据属性。 </li><li>如果数据属性是不可配置的，则不能将它转换为存取器属性。 </li><li>如果数据属性是不可配置的，则不能将它的可写性从false修改为true，但可以从true修改为false。</li><li>如果数据属性是不可配置且不可写的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的（实际上是先将它标记为可写的，然后修改它的值，最后转换为不可写的）。</li></ul><p><em>以两条下划线作前缀，两条下划线作后缀，以表明它们是非标准的方法</em></p><h2 id="6-8-对象的属性"><a href="#6-8-对象的属性" class="headerlink" title="6.8 对象的属性"></a>6.8 对象的属性</h2><p><strong>原型属性 prototype attribute</strong><br>对象的原型属性是用来继承属性的。通常”o的原型属性” 叫 “o的原型”。<br>Object.getPrototypeOf() 查询对象的原型 (o.constructor.prototype方法不可靠)<br>isPrototypeOf() 检测一个对象是否是另一个对象的原型（或处于原型链中）</p><p><strong>类属性 class attribute</strong><br>表示对象的类型信息。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">classof</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o === <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">"Null"</span>;</div><div class="line">    <span class="keyword">if</span> (o === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="string">"Undefined"</span>;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">classof(<span class="literal">null</span>)<span class="comment">//=&gt;"Null"</span></div><div class="line">classof(<span class="number">1</span>)<span class="comment">//=&gt;"Number"</span></div><div class="line">classof(<span class="string">""</span>)<span class="comment">//=&gt;"String"</span></div><div class="line">classof(<span class="literal">false</span>)<span class="comment">//=&gt;"Boolean"</span></div><div class="line">classof(&#123;&#125;)<span class="comment">//=&gt;"Object"</span></div><div class="line">classof([])<span class="comment">//=&gt;"Array"</span></div><div class="line">classof(<span class="regexp">/./</span>)  <span class="comment">//=&gt;"RegExp"</span></div><div class="line">classof(<span class="keyword">new</span> <span class="built_in">Date</span>())  <span class="comment">//=&gt;"Date"</span></div><div class="line">classof(<span class="built_in">window</span>)  <span class="comment">//=&gt;"Window"</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;   </div><div class="line">classof(<span class="keyword">new</span> f())  <span class="comment">//=&gt;"Object"</span></div></pre></td></tr></table></figure></p><p><strong>可扩展性属性 extensible attribute</strong><br>表示是否可以给对象添加新属性。所有内置、自定义对象都是显式可扩展。 目的是将对象“锁定”，以避免外界的干扰。</p><ul><li>Object.jsExtensible()来判断对象是否是可扩展的。 </li><li>Object.preventExtensions()将对象转换为不可扩展的。一旦将对象转换为不可扩展的话就无法转换为可扩展的了。只影响对象本身的可扩展性，该对象的原型添加属性，该对象会继承新属性。  </li><li>Object.seal() 能够将对象设置为不可扩展的，将对象的所有自有属性都设置为不可配置的。</li><li>不能给这个对象添加新属性，而且它已有的属性也不能删除或配置，不过它已有的可写属性依然可以设置。对于那些已经封闭（sealed）起来的对象是不能解封的。Object.isSealed()来检测对象是否封闭。  </li><li>Object.freeze() “冻结”（frozen）。 将对象设置为不可扩展的和将其属性设置为不可配置的之外，还可以将它自有的所有数据属性设置为只读（如果对象的存取器属性具有setter方法，存取器属性将不受影响，仍可以通过给属性赋值调用它们）。 Object.isFrozen()来检测对象是否冻结。</li></ul><h2 id="6-9-序列化对象（serialization）"><a href="#6-9-序列化对象（serialization）" class="headerlink" title="6.9 序列化对象（serialization）"></a>6.9 序列化对象（serialization）</h2><p>指将对象的状态转换为字符串，也可将字符串还原为对象.</p><ul><li>NaN、Infinity和-Infinity序列化的结果是null</li><li>日期对象序列化的结果是ISO格式的日期字符串（Date.toJSON()函数），但JSON.parse()依然保留它们的字符串形态，而不会将它们还原为原始日期对象。</li><li>函数、RegExp、Error对象和undefined值不能序列化和还原。</li><li>JSON.stringify()只能序列化对象可枚举的自有属性。</li></ul>]]></content>
    
    <summary type="html">
    
      表达式、语句、对象。
    
    </summary>
    
      <category term="FrontEnd" scheme="http://anduril.cn/categories/FrontEnd/"/>
    
    
      <category term="JavaScript" scheme="http://anduril.cn/tags/JavaScript/"/>
    
      <category term="Reading" scheme="http://anduril.cn/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>0x01.犀牛书札记(ch1-3)</title>
    <link href="http://anduril.cn/2018/04/29/js-6th-notes-ch1-3/"/>
    <id>http://anduril.cn/2018/04/29/js-6th-notes-ch1-3/</id>
    <published>2018-04-29T06:46:57.000Z</published>
    <updated>2018-05-06T13:12:00.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本书资源<br><a href="http://shop.oreilly.com/product/9780596805531.do" target="_blank" rel="external">http://shop.oreilly.com/product/9780596805531.do</a></p></blockquote><h1 id="ch1-语言介绍"><a href="#ch1-语言介绍" class="headerlink" title="ch1 语言介绍"></a>ch1 语言介绍</h1><p>内容 HTML  行为JS  样式CSS<br>高端、动态、弱语言，非常适合面向对象和函数式编程风格<br>特点：一等函数(first-class function)、基于原型(prototype-based)</p><p>输入输出功能由宿主环境（host enviroment）提供 ，基于浏览器的API统称为客户端JavaScript </p><p>函数和对象合写在一起，函数就变成了”方法 method”</p><h1 id="ch2-词法结构"><a href="#ch2-词法结构" class="headerlink" title="ch2 词法结构"></a>ch2 词法结构</h1><p>标签和属性必须小写.<br>Js会忽略程序中标识(token)之间的空格，也会忽略换行符。<br>回车符(\u000D) 加 换行符(\u000A)在一起被解析为一个单行结束符。<br>Unicode 转义序列  \uXXXX  X为16进制数    “café” === ‘caf\u00e9’</p><p>直接量（ literal）是程序中直接使用的数据值。  (数字、字符串、正则表达式、数组、对象等直接量)<br>标识符必须以字母、下划线(_)或美元符($)开始。后续的字符可以是字母、数字、下划线或美元符。</p><p>只有在缺少了分号就无法正确解析代码的时候，JavaScript才会填补分号。如果当前语句和随后的非空格字符不能当成一个整体来解析的话，JavaScript就在当前语句行结束处填补分号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">var a</div><div class="line">a</div><div class="line">=</div><div class="line">3 </div><div class="line">console.log(a)</div><div class="line">//解析成 var a; a = 3; console.log(a);</div><div class="line"></div><div class="line">var x = 0 // 这里省略了分号</div><div class="line">;[x,x+1,x+2].forEach(console.log) // 前面的分号保证了正确地语句解析</div><div class="line">*/</div></pre></td></tr></table></figure><h1 id="ch3-类型、值、变量"><a href="#ch3-类型、值、变量" class="headerlink" title="ch3  类型、值、变量"></a>ch3  类型、值、变量</h1><p>数据类型分类：</p><ul><li>原始类型（primitive type）</li><li>对象类型（object type）</li></ul><p>原始类型包括</p><ul><li>数字</li><li>字符串</li><li>布尔值</li><li>null（空）</li><li>undefined（未定义）</li></ul><p>对象类型（object type）  是属性(property)的集合。 </p><ul><li>全局对象(global object)   </li><li>数组(array)带编号的有序集合 </li><li>函数</li></ul><p><strong>函数 </strong><br>如果函数用来初始化（使用new运算符）一个新建的对象，我们称之为构造函数（constructor）。每个构造函数定义了一类（class）对象–构造函数初始化对象组成的集合。类可以看做对象类型的子类型。 </p><ul><li>数组（Array）类</li><li>函数（Function）类 </li><li>日期（Date）类定义了代表日期的对象。</li><li>正则（RegExp）类定义了表示正则表达式的对象，强大通用的文本处理工具。</li><li>错误（Error）类定义了那些表示JavaScript程序中运行时错误和语法错误的对象。</li></ul><p>js中只有对象才能拥有方法。数字，字符串，布尔值也拥有自己的方法。只有null和undefined是无法拥有方法的值。</p><ul><li>可变（mutable）</li><li>不可变(immutable)<br>对象、数组、函数属于可变类型<br>字符串、数字、布尔值、null和undefined属于不可改变的类型。 </li></ul><p>js的变量是无类型的（untyped），变量可以被赋予任何类型的值，使用var关键字来声明（declare）变量。javascript采用语法作用域，不在任何函数内声明的变量称为全局变量（global variable）它在程序中任何地方都是可见的。</p><h2 id="3-1数字"><a href="#3-1数字" class="headerlink" title="3.1数字"></a>3.1数字</h2><p>数字均用浮点数值表示。采用64位浮点格式表示数字，实际的操作（数组索引，位操作符）则是基于32位整数。   </p><p><strong>数字直接量（numeric literal）</strong><br>十六进制 “0x”或“0X”   八进制  0开头   0377 ECMAScript 6的严格模式下，八进制直接量是明令禁止的   </p><p><strong>溢出（overflow）</strong><br>的数字上限（溢出），结果为一个特殊的无穷大（infinity）值，以Infinity表示。当负数的值超过了负数范围，结果为负无穷大以－Infinity表示。<br>无穷大值：基于它们的加、减、乘和除运算结果还是无穷大值（保留正负号）。<br><strong>下溢（underflow）</strong><br>当运算结果无限接近于零并比JavaScript能表示的最小值还小的时候发生的一种情形。返回0。负数发生下溢时，返回“负零”。</p><p><strong>被零整除</strong><br>被零整除并不报错：返回无穷大（Infinity）或负无穷大（－Infinity）。<br>零除以零运算结果也是一个非数字（not-a-number）值，用NaN表示。无穷大除以无穷大、给任意负数作开方运算或者算术运算符与不是数字或无法转换为数字的操作数一起使用时都将返回NaN。<br>NaN和任何值都不相等，包括自身。当且仅当x为NaN的时候，表达式x!=x的结果才为true。<br>函数isNaN()，如果参数是NaN或者是一个非数字值（比如字符串和对象），则返回true。<br>函数isFinite()，在参数不是NaN、Infinity或-Infinity的时候返回true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="literal">Infinity</span>/<span class="number">0</span>   <span class="comment">//Infinity</span></div><div class="line"><span class="number">0</span>/<span class="number">0</span>    <span class="comment">//NaN</span></div><div class="line"><span class="literal">Infinity</span>/<span class="literal">Infinity</span>    <span class="comment">//NaN</span></div><div class="line"><span class="built_in">Number</span>.MIN_VALUE/<span class="number">2</span>     <span class="comment">//下溢 0 </span></div><div class="line"></div><div class="line"><span class="literal">Infinity</span>==-<span class="literal">Infinity</span>  <span class="comment">//=&gt;false  非数值和任何值（包括自身）都不相等。</span></div></pre></td></tr></table></figure><p><strong>浮点数表示法精度</strong><br>二进制浮点数表示法并不能精确表示十进制的分数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">.3</span><span class="number">-.2</span>  <span class="comment">//=&gt;0.09999999999999998</span></div><div class="line"><span class="number">.2</span><span class="number">-.1</span>  <span class="comment">//=&gt;0.1</span></div></pre></td></tr></table></figure></p><h2 id="3-2-文本"><a href="#3-2-文本" class="headerlink" title="3.2 文本"></a>3.2 文本</h2><p>字符串（string）是一组由16位值组成的不可变的有序序列。JavaScript通过字符串类型来表示文本。字符串的长度（length）是其所含16位值的个数。空字符串（empty string）长度为0，JavaScript中并没有表示单个字符的“字符型”。</p><p>字符串是固定不变的，一些方法都返回新字符串，原字符串本身并没有发生改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ECMAScript 5中，字符串直接量可以拆分成数行，每行必须以反斜线（\）结束，反斜线和行结束符都不算是字符串直接量的内容。</span></div><div class="line"><span class="comment">//=&gt; "onelongline"</span></div><div class="line"><span class="string">"one\</span></div><div class="line">long\</div><div class="line">line"</div></pre></td></tr></table></figure><p><strong>转义字符(escape sequence)</strong><br>转义字符 含义<br>\o NUL字符(\u0000)<br>\b 退格符(\u0008)<br>\t 水平制表符(\u0009)<br>\n 换行符(\u000A)<br>\v 垂直制表符(\u000B)<br>\f 换页符(\u000C)<br>\r 回车符(\u000D)<br>\” 双引号(\u0022)<br>\’ 撇号或单引号(\u0027)<br>\ 反斜线(\u005C)<br>\xXX 由两位十六进制数XX指定的Latin-1字符<br>\uXXXX 由4位十六进制数XXXX指定的Unicode字符</p><h2 id="3-3-布尔值"><a href="#3-3-布尔值" class="headerlink" title="3.3 布尔值"></a>3.3 布尔值</h2><p>任意JavaScript的值都可以转换为布尔值。false和下面6个可以转换成false的值有时称做“假值”(falsy value）；所有其他值，包括所有对象（数组）都会转换成true，其他值称做“真值”(truthy value)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="literal">undefined</span></div><div class="line"><span class="literal">null</span></div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">-0</span></div><div class="line"><span class="literal">NaN</span></div><div class="line"><span class="string">""</span> <span class="comment">// 空字符串</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> == <span class="literal">null</span> )      <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> == <span class="literal">undefined</span> ) <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> == <span class="number">0</span> )         <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> == <span class="string">''</span> )        <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> == <span class="literal">NaN</span> )       <span class="comment">// false</span></div></pre></td></tr></table></figure><h2 id="3-4-null、undefined"><a href="#3-4-null、undefined" class="headerlink" title="3.4 null、undefined"></a>3.4 null、undefined</h2><p>两者不包含任何属性和方法。 <strong>变量、属性赋值、参数传入 推荐使用null.</strong><br>null是关键字，描述“空值”。null认为是一个特殊的对象值，含义是“非对象”。null是它自有类型的唯一一个成员，它可以表示数字、字符串和对象是“无值”的。</p><p>undefined(未定义的值)表示更深层次的“空值”。</p><ul><li>变量没有初始化</li><li>查询对象属性或数组元不存在</li><li>函数没有返回任何值，则返回undefined</li><li>引用没有提供实参的函数形参的值</li><li>undifined是这个类型的唯一成员</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span>(<span class="literal">null</span>);  <span class="comment">//=&gt; object</span></div><div class="line"><span class="keyword">typeof</span>(undifined); <span class="comment">//=&gt; undifined</span></div><div class="line"><span class="literal">null</span> == <span class="literal">undefined</span>;  <span class="comment">//=&gt; true</span></div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"></div><div class="line">## 3.5 全局对象（global object）</div><div class="line">当JavaScript解释器启动时将创建一个新的全局对象,并定义如下属性</div><div class="line">- 全局属性</div><div class="line">- 全局函数</div><div class="line">- 构造函数</div><div class="line">- 全局对象</div><div class="line"></div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="comment">//使用JavaScript关键字this来引用全局对象</span></div><div class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>; <span class="comment">// 定义一个引用全局对象的全局变量</span></div></pre></td></tr></table></figure><h2 id="3-6-包装对象"><a href="#3-6-包装对象" class="headerlink" title="3.6 包装对象"></a>3.6 包装对象</h2><p>存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象(一种实现细节)。<br>只要引用了属性，JavaScript就会将字面量通过调用new String()／Number()／ Boolean()构造函数创建一个临时对象，这些方法的调用均是来自于这个临时对象。<br>一旦属性引用结束，这个新创建的对象就会销毁。<br>null和undefined没有包装对象：访问它们的属性会造成一个类型错误。   </p><p>“==”等于运算符将原始值和其包装对象视为相等，   === 全等运算符视为不等 </p><p>var s = “test”, n = 1, b = true;  // 一个字符串、数字和布尔值<br>//显示创建包装对象<br>var S = new String(s);   // 一个字符串对象<br>var N = new Number(n);   // 一个数值对象<br>var B = new Boolean(b);   // 一个布尔对象   </p><p>console.log( s == S );         // true<br>console.log( s === S );         // false<br>typeof(s);   //  “string”<br>typeof(S);   //  “object”     </p><h2 id="3-7-不可变的原始值和可变的对象引用"><a href="#3-7-不可变的原始值和可变的对象引用" class="headerlink" title="3.7 不可变的原始值和可变的对象引用"></a>3.7 不可变的原始值和可变的对象引用</h2><p>对象（包括数组和函数）称为引用类型（reference type）， 对象的比较均是引用的比较：当且仅当它们引用同一个基对象时，它们才相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, p = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</div><div class="line">o === p;     <span class="comment">// false</span></div><div class="line"><span class="keyword">var</span> a = [], b = [];</div><div class="line">a === b;     <span class="comment">// false</span></div></pre></td></tr></table></figure><h2 id="3-8-类型转换"><a href="#3-8-类型转换" class="headerlink" title="3.8 类型转换"></a>3.8 类型转换</h2><table><thead><tr><th>值/from</th><th>字符串/to</th><th>数字/to</th><th>布尔值/to</th><th>对象/to  </th></tr></thead><tbody><tr><td>undefined</td><td>“undefined”</td><td>NaN</td><td>false</td><td>throws TypeError </td></tr><tr><td>null</td><td>“null”</td><td>0</td><td>false</td><td>throws TypeError </td></tr><tr><td>true</td><td>“true”</td><td>1</td><td></td><td>new Boolean(true)</td></tr><tr><td>false</td><td>“false”</td><td>0</td><td></td><td>new Boolean(false)</td></tr><tr><td>“”(空字符串)</td><td></td><td>0</td><td>false</td><td>new String(“”) </td></tr><tr><td>“1.2”</td><td></td><td>1.2</td><td>true</td><td>new String(“1.2”) </td></tr><tr><td>“one”</td><td></td><td>NaN</td><td>true</td><td>new String(“one”) </td></tr><tr><td>0</td><td>“0”</td><td></td><td>false</td><td>new Number(0)</td></tr><tr><td>-0</td><td>“0”</td><td></td><td>false</td><td>new Number(-0)</td></tr><tr><td>NaN</td><td>“NaN”</td><td></td><td>false</td><td>new Number(NaN)</td></tr><tr><td>Infinity</td><td>“Infinity”</td><td></td><td>true</td><td>new Number(Infinity)</td></tr><tr><td>-Infinity</td><td>“-Infinity”</td><td></td><td>true</td><td>new Number(-Infinity)</td></tr><tr><td>1</td><td>“1”</td><td></td><td>true</td><td>new Number(1)</td></tr><tr><td>{}(任意对象)</td><td>明细</td><td>明细</td><td>true</td><td></td></tr><tr><td>[] (任意数组)</td><td>“”</td><td>0</td><td>true</td><td></td></tr><tr><td>[9] (1个数字元素)</td><td>“9”</td><td>9</td><td>true</td><td></td></tr><tr><td>[‘a’] (其他数组)</td><td>join()方法</td><td>NaN</td><td>true</td><td></td></tr><tr><td>function(){}(任意函数)</td><td>明细</td><td>NaN</td><td>true</td><td></td></tr></tbody></table><p><strong>转换和相等性</strong></p><p>== 在判断时进行了类型转换， 一个值转换为另一个值并不意味着两个值相等。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//undefined转换成false    </span></div><div class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">//false</span></div></pre></td></tr></table></figure><p><strong>显示类型转换</strong></p><p>最简单的方法就是使用Boolean()、Number()、String()或Object()函数。除了null或undefined之外的任何值都具有toString()方法，这个方法的执行结果通常和String()方法的返回结果一致。</p><ul><li>“+”运算符的一个操作数是字符串，将会把另外一个操作数转换为字符串。</li><li>一元“+”运算符将其操作数转换为数字。</li><li>一元“！”运算符将其操作数转换为布尔值并取反。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x + <span class="string">""</span>  <span class="comment">// String(x)</span></div><div class="line">+x  <span class="comment">// Number(x)  x-0</span></div><div class="line">!!x <span class="comment">// Boolean(x)</span></div></pre></td></tr></table></figure><p>toString()方法 可以接收表示转换基数（radix）的可选参数，如果不指定此参数，转换规则将是基于十进制。支持进制数（范围在2～36之间）</p><p><strong>parseInt()函数 parseFloat()函数（全局函数）</strong></p><p>如果字符串前缀是“0x”或者“0X”，parseInt()将其解释为十六进制数，方法会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回NaN。<br>parseInt()可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2～36</p><h3 id="3-8-3对象转换为原始值"><a href="#3-8-3对象转换为原始值" class="headerlink" title="3.8.3对象转换为原始值"></a>3.8.3对象转换为原始值</h3><p>所有的对象（包括数组和函数）都转换为true。 适用于包装对象，<strong>new Boolean(false)是一个对象而不是原始值，它将转换为true。</strong></p><p>++只适用于本地对象（native object）++  对象继承了俩个转换方法：</p><p> <strong>1.toString()</strong></p><ul><li>默认的toString()方法返回  “[object Object]”</li><li>数组类（Array class）将每个数组元素转换为一个字符串，并在元素之间添加逗号后合并成结果字符串。</li><li>函数类（Function class）返回这个函数的实现定义的表示方式。</li><li>日期类（Date class）返回了一个可读的（可被JavaScript解析的）日期和时间字符串。</li><li>RegExp类（RegExp class）将RegExp对象转换为表示正则表达式直接量的字符串。</li></ul><p><strong>2.valueOf()</strong><br>如果存在任意原始值，它就默认将对象转换为表示它的原始值。<br>对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。</p><ul><li>数组、函数和正则表达式 返回对象本身。</li><li>日期类 返回它的一个内部表示：1970年1月1日以来的毫秒数。</li></ul><h4 id="步骤：对象到字符串（object-to-string）"><a href="#步骤：对象到字符串（object-to-string）" class="headerlink" title="步骤：对象到字符串（object-to-string）"></a>步骤：对象到字符串（object-to-string）</h4><ol><li>如果对象具有toString()方法，则调用这个方法。如果它返回一个<strong>原始值</strong>，JavaScript将这个值转换为字符串(如果本身不是字符串的话)，并返回这个字符串结果。</li><li>如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么JavaScript会调用valueOf()方法。如果存在这个方法，则JavaScript调用它。如果返回值是原始值，JavaScript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。</li><li>否则，JavaScript无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常。</li></ol><h4 id="步骤：对象到数字（object-to-number）"><a href="#步骤：对象到数字（object-to-number）" class="headerlink" title="步骤：对象到数字（object-to-number）"></a>步骤：对象到数字（object-to-number）</h4><ol><li>如果对象具有valueOf()方法，后者返回一个原始值，则JavaScript将这个原始值转换为数字并返回这个数字。</li><li>否则，如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回。</li><li>否则，JavaScript抛出一个类型错误异常。</li></ol><p>数组是对象，调用valueOf方法无法返回原始值，所以调用toString().空数组转换成空字符串，然后空字符串转化成0;含一个元素的数组转换为字符串结果，然后转化为数值。</p><p><strong>运算符</strong></p><p>“+” 可以数字和字符串连接操作，若果一个操作数时对象，对象转为原始值。<br>“==” 原始值和对象比较，对象转换为原始值进行比较。</p><p>对象到原始值的转换：非日期对象先尝试调用valueOf()，然后调用toString()返回的原始值将被直接使用，不会被强制转换为数字或字符串；日期对象直接转换成字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="string">"2"</span>+<span class="number">3</span>   <span class="comment">//"23"</span></div><div class="line"><span class="number">2</span>+[<span class="number">2</span>]   <span class="comment">//"22"</span></div><div class="line"><span class="number">2</span>+[<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//"22,3"</span></div><div class="line"><span class="number">2</span>+[]    <span class="comment">//"2"</span></div><div class="line">[<span class="number">2</span>]==<span class="number">2</span>  <span class="comment">//true</span></div><div class="line">[<span class="number">2</span>]==<span class="string">'2'</span> <span class="comment">//true</span></div><div class="line">[]==<span class="string">''</span>  <span class="comment">//true</span></div><div class="line"> </div><div class="line"><span class="comment">//日期对象</span></div><div class="line"><span class="keyword">var</span> now=<span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line"><span class="keyword">typeof</span>(now+<span class="number">1</span>)   <span class="comment">//"string"</span></div><div class="line"><span class="keyword">typeof</span>(now<span class="number">-1</span>)   <span class="comment">//"number"</span></div><div class="line">now==now.toString()  <span class="comment">//true</span></div><div class="line">now&gt;(now<span class="number">-1</span>)   <span class="comment">//true</span></div></pre></td></tr></table></figure><h2 id="3-10-变量作用域"><a href="#3-10-变量作用域" class="headerlink" title="3.10 变量作用域"></a>3.10 变量作用域</h2><p>变量值初始值时 undefined. 没有块级作用域（block scope）。 函数作用域（function scope）：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。      </p><p><strong>声明提前（hoisting）</strong><br>函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部.  变量声明放在函数体顶部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"undefined"，而不是"global"</span></div><div class="line"> <span class="keyword">var</span> scope = <span class="string">"local"</span>; <span class="comment">// 变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的</span></div><div class="line"> <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"local"</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//等价于</span></div><div class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="keyword">var</span> scope;</div><div class="line"> <span class="built_in">console</span>.log(scope);  </div><div class="line"> scope = <span class="string">"local"</span>;  </div><div class="line"> <span class="built_in">console</span>.log(scope);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong> 全局变量（global variable） </strong></p><p>当声明一个JavaScript全局变量时，实际上是定义了全局对象的一个属性。</p><ul><li>当使用var声明一个变量时，创建的这个属性是不可配置的，无法通过delete运算符删除。</li><li>在非严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量，是可配置属性，可以删除。</li></ul><p><strong> 作用域链（scope chain）</strong></p><p>JavaScript是基于词法作用域（lexical scoping）的语言：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。</p><p>当JavaScript需要查找变量x的值的过程称做“变量解析”（variable resolution）</p><p>在最顶层代码中（也就是不包含在任何函数定义内的代码），作用域链由一个全局对象组成。</p><p>在不包含嵌套的函数体内，作用域链上有两个对象，<br>第一个是定义函数参数和局部变量的对象，<br>第二个是全局对象。<br>在一个嵌套的函数体内，作用域链上至少有三个对象。</p><blockquote><p>当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。<br>对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。</p></blockquote>]]></content>
    
    <summary type="html">
    
      词法、类型、变量。
    
    </summary>
    
      <category term="FrontEnd" scheme="http://anduril.cn/categories/FrontEnd/"/>
    
    
      <category term="JavaScript" scheme="http://anduril.cn/tags/JavaScript/"/>
    
      <category term="Reading" scheme="http://anduril.cn/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>当我们谈论旅行时我们在谈论什么</title>
    <link href="http://anduril.cn/2017/06/19/what-travel-means-to-us/"/>
    <id>http://anduril.cn/2017/06/19/what-travel-means-to-us/</id>
    <published>2017-06-18T17:17:56.000Z</published>
    <updated>2017-06-19T14:29:20.000Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/what-travel-means-to-us-header.jpg" class="full-image"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p> You can either travel or read, but either your body or soul must be on the way.<br><strong>Roman Holiday</strong> </p></blockquote><h2 id="0x01-旅行意味着什么"><a href="#0x01-旅行意味着什么" class="headerlink" title="0x01.旅行意味着什么"></a>0x01.旅行意味着什么</h2><p>“要么读书，要么旅行，身体和灵魂总有一个在路上”，诚然这种生活境界很难做到。幸运的是，我们的出行随着交通的发展更加便捷。“但是自问为什么要去旅行呢？或者我们为了什么而去旅行？”</p><p>我喜欢喜欢深入到大自然，游览大好河山，陶冶情操。在旅行中，抛开生活工作中的电话和邮件，忘掉一切，你就是你自己，没有任何职位角色，聚焦于眼前的目标–攀爬一座山头或是骑行一段路程，努力的与时间赛跑，与周围的环境融为一体，即使身体的疲劳酸痛也不能阻止精神的自由翱翔！这就是所谓的“旅行的乐趣”。</p><p>每个人的生活就是一个圈子，时间久了我们对人物都会由熟悉到嫌弃，一成不变的生活方式是很难让人满意。在旅行的路上我们可以结识志同道合的朋友，打开你的视野和思维，体验不同风俗文化间的差异，一次短暂的消失，让你不会对生活感到疲惫。</p><p>这种角色的互换充满了欢愉，却又如夜空中烟花般短暂美丽，却仍是生活这篇章跳动的乐符。</p><h2 id="0x02-阅读意味着什么"><a href="#0x02-阅读意味着什么" class="headerlink" title="0x02.阅读意味着什么"></a>0x02.阅读意味着什么</h2><p>旅行中我会带个kindle和一本纸质书，在文字地伴随下帮你度过路途中枯燥和无聊。</p><p>旅行相较于阅读，感官更加直接，画面感更强，所以我比较喜欢旅行。即使我喜欢旅行，花在阅读的时间更多，因为后者消耗更少的金钱和精力，所谓的投资回报率最高。</p><p>在这个快节奏的时代，知识付费横飞，我为什么还要一句句的阅读思考呢？不是有“成品”销售吗？当然你可以为此付些智商税，别人也拦不住。</p><p>当下的我们每天沉浸在微博、朋友圈、知乎，看着一些碎片化的“知识”而一知半解；缺乏阅读积累的思考，只是对少数话语的迷信；缺乏思考的阅读，只是对已有话语的模仿，其实这是“博识的无知”。杨绛先生的“想法太多，读书太少”描述最为贴切。</p><p>聪明的读者会知道自己没有什么，自己需要学习什么。通过系统阅读可以花最少的成本来构建自己的知识架构，可以让你在生活、工作中快速的成长，最重要的时让你学会自主的思考和独立的人格，在生活中不会随波而流！</p><h2 id="0x03-追寻远方"><a href="#0x03-追寻远方" class="headerlink" title="0x03.追寻远方"></a>0x03.追寻远方</h2><p>我热爱阅读和旅行，我热爱生活！是因为我从之感受生活的希望，那么多美好的事物，生活展示出那么多可能性。世界如此美好，我应为只奋斗！我能有什么理由放弃呢！</p><p>读万卷书，行万里路！</p><p>共勉之。</p><p>– 写于苏州</p>]]></content>
    
    <summary type="html">
    
      要么读书，要么旅行，身体和灵魂总有一个在路上!
    
    </summary>
    
      <category term="Life" scheme="http://anduril.cn/categories/Life/"/>
    
    
      <category term="Reading" scheme="http://anduril.cn/tags/Reading/"/>
    
      <category term="Travel" scheme="http://anduril.cn/tags/Travel/"/>
    
  </entry>
  
  <entry>
    <title>thoughtworks读书雷达计划</title>
    <link href="http://anduril.cn/2016/04/27/thoughtworks-reading-rader-plan/"/>
    <id>http://anduril.cn/2016/04/27/thoughtworks-reading-rader-plan/</id>
    <published>2016-04-27T12:00:00.000Z</published>
    <updated>2017-06-19T12:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>纸上得来终觉浅，绝知此事要躬行！</p><p>系统的进行阅读，然后尝试实践！计划长期有效！贴出豆瓣书单！</p><h2 id="Coding-Practice（编程实践）"><a href="#Coding-Practice（编程实践）" class="headerlink" title="Coding Practice（编程实践）"></a>Coding Practice（编程实践）</h2><p><a href="https://www.douban.com/doulist/44364662/" target="_blank" rel="external">豆单</a>    </p><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><blockquote><p>Clean Code《代码整洁之道》<br>Pragmatic Unit Testing《单元测试之道》<br>The Productive Programmer《卓有成效的程序员》<br>Test-Driven Development By Example《测试驱动开发》<br>Clean Coder《程序员的职业修养》<br>The Art of Readable Code《编写可读代码的艺术》</p></blockquote><h3 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h3><blockquote><p>Refactoring To Patterns《重构与模式》<br>Implementation Patterns《实现模式》<br>Code Complete《代码大全》<br>The Pragmatic Programmer《程序员修炼之道》</p></blockquote><h3 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h3><blockquote><p>Structure and Interpretation of Computer Programs《计算机程序的构造和解释》<br>Working Effectively with Legacy Code《修改代码的艺术》</p></blockquote><h2 id="Architecture-amp-Design（架构与设计）"><a href="#Architecture-amp-Design（架构与设计）" class="headerlink" title="Architecture &amp; Design（架构与设计）"></a>Architecture &amp; Design（架构与设计）</h2><h3 id="基础篇-1"><a href="#基础篇-1" class="headerlink" title="基础篇"></a>基础篇</h3><blockquote><p>Agile Software Development 《敏捷软件开发：原则、实践与模式》<br>Head First Design Patterns《深入浅出设计模式》<br>Design Patterns 《设计模式》</p></blockquote><h3 id="进阶篇-1"><a href="#进阶篇-1" class="headerlink" title="进阶篇"></a>进阶篇</h3><blockquote><p>The Art of UNIX Programming 《Unix编程艺术》<br>Practical API Design 《框架设计的艺术》<br>Domain Specific Languages 《领域特定语言》<br>Patterns of Enterprise Application Architecture 《企业应用架构模式》</p></blockquote><h3 id="高级篇-1"><a href="#高级篇-1" class="headerlink" title="高级篇"></a>高级篇</h3><blockquote><p>Release It<br>Domain-Driven Design 《领域驱动设计》<br>Enterprise Integration Patterns《企业集成模式》<br>Beautiful Architecture《架构之美》<br>Pattern-Oriented Software Architecture《面向模式的软件架构》</p></blockquote><h2 id="Methodology（方法学）"><a href="#Methodology（方法学）" class="headerlink" title="Methodology（方法学）"></a>Methodology（方法学）</h2><h3 id="基础篇-2"><a href="#基础篇-2" class="headerlink" title="基础篇"></a>基础篇</h3><blockquote><p>User Stories Applied《用户故事与敏捷方法》<br>The Gold Mine《金矿》<br>Scrum and XP From the Trenches《硝烟中的Scrum和XP》<br>Continuous Integration《持续集成》<br>Extreme Programming Explained《解析极限编程》</p></blockquote><h3 id="进阶篇-2"><a href="#进阶篇-2" class="headerlink" title="进阶篇"></a>进阶篇</h3><blockquote><p>Lean Thinking《精益思想》<br>Continuous Delivery《持续交付》<br>How Google Tests Software<br>Agile Testing<br>Extreme Programming Refactored《重构极限编程》</p></blockquote><h3 id="高级篇-2"><a href="#高级篇-2" class="headerlink" title="高级篇"></a>高级篇</h3><blockquote><p>Specification By Example</p></blockquote><h2 id="Thought-amp-Leadership（思想与领导力）"><a href="#Thought-amp-Leadership（思想与领导力）" class="headerlink" title="Thought &amp; Leadership（思想与领导力）"></a>Thought &amp; Leadership（思想与领导力）</h2><h3 id="基础篇-3"><a href="#基础篇-3" class="headerlink" title="基础篇"></a>基础篇</h3><blockquote><p>The Effective Executive《卓有成效的管理者》<br>Are Your Lights On?《你的灯亮着吗》<br>Becoming A Technical Leader《成为技术领导者》</p></blockquote><h3 id="进阶篇-3"><a href="#进阶篇-3" class="headerlink" title="进阶篇"></a>进阶篇</h3><blockquote><p>The Fifth Discipline《第五项修炼》<br>The Design Of Business<br>Management 3.0《管理3.0：培养和提升敏捷领导力》<br>Presentation To Win<br>The McKinsey Way《麦肯锡方法》</p></blockquote><h3 id="高级篇-3"><a href="#高级篇-3" class="headerlink" title="高级篇"></a>高级篇</h3><blockquote><p>Thinking, Fast and Slow《思考快与慢》</p></blockquote><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="http://agiledon.github.io/blog/2013/04/17/thoughtworks-developer-reading-radar/" target="_blank" rel="external">http://agiledon.github.io/blog/2013/04/17/thoughtworks-developer-reading-radar/</a></p>]]></content>
    
    <summary type="html">
    
      想法太多，读书太少!
    
    </summary>
    
      <category term="Programmer" scheme="http://anduril.cn/categories/Programmer/"/>
    
    
      <category term="Reading" scheme="http://anduril.cn/tags/Reading/"/>
    
  </entry>
  
</feed>
