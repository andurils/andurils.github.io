<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anduril</title>
  
  <subtitle>一枚鸡蛋狂热者的疯言疯语</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://anduril.cn/"/>
  <updated>2018-04-29T07:36:28.000Z</updated>
  <id>http://anduril.cn/</id>
  
  <author>
    <name>Hejin Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>0x01.犀牛书札记(ch1-3)</title>
    <link href="http://anduril.cn/2018/04/29/js-6th-notes-ch1-3/"/>
    <id>http://anduril.cn/2018/04/29/js-6th-notes-ch1-3/</id>
    <published>2018-04-29T06:46:57.000Z</published>
    <updated>2018-04-29T07:36:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本书资源<br><a href="http://shop.oreilly.com/product/9780596805531.do" target="_blank" rel="external">http://shop.oreilly.com/product/9780596805531.do</a></p></blockquote><h1 id="ch1-语言介绍"><a href="#ch1-语言介绍" class="headerlink" title="ch1 语言介绍"></a>ch1 语言介绍</h1><p>内容 HTML  行为JS  样式CSS<br>高端、动态、弱语言，非常适合面向对象和函数式编程风格<br>特点：一等函数(first-class function)、基于原型(prototype-based)</p><p>输入输出功能由宿主环境（host enviroment）提供 ，基于浏览器的API统称为客户端JavaScript </p><p>函数和对象合写在一起，函数就变成了”方法 method”</p><h1 id="ch2-词法结构"><a href="#ch2-词法结构" class="headerlink" title="ch2 词法结构"></a>ch2 词法结构</h1><p>标签和属性必须小写.<br>Js会忽略程序中标识(token)之间的空格，也会忽略换行符。<br>回车符(\u000D) 加 换行符(\u000A)在一起被解析为一个单行结束符。<br>Unicode 转义序列  \uXXXX  X为16进制数    “café” === ‘caf\u00e9’</p><p>直接量（ literal）是程序中直接使用的数据值。  (数字、字符串、正则表达式、数组、对象等直接量)<br>标识符必须以字母、下划线(_)或美元符($)开始。后续的字符可以是字母、数字、下划线或美元符。</p><p>只有在缺少了分号就无法正确解析代码的时候，JavaScript才会填补分号。如果当前语句和随后的非空格字符不能当成一个整体来解析的话，JavaScript就在当前语句行结束处填补分号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">var a</div><div class="line">a</div><div class="line">=</div><div class="line">3 </div><div class="line">console.log(a)</div><div class="line">//解析成 var a; a = 3; console.log(a);</div><div class="line"></div><div class="line">var x = 0 // 这里省略了分号</div><div class="line">;[x,x+1,x+2].forEach(console.log) // 前面的分号保证了正确地语句解析</div><div class="line">*/</div></pre></td></tr></table></figure><h1 id="ch3-类型、值、变量"><a href="#ch3-类型、值、变量" class="headerlink" title="ch3  类型、值、变量"></a>ch3  类型、值、变量</h1><p>数据类型分类：</p><ul><li>原始类型（primitive type）</li><li>对象类型（object type）</li></ul><p>原始类型包括</p><ul><li>数字</li><li>字符串</li><li>布尔值</li><li>null（空）</li><li>undefined（未定义）</li></ul><p>对象类型（object type）  是属性(property)的集合。 </p><ul><li>全局对象(global object)   </li><li>数组(array)带编号的有序集合 </li><li>函数</li></ul><p><strong>函数 </strong><br>如果函数用来初始化（使用new运算符）一个新建的对象，我们称之为构造函数（constructor）。每个构造函数定义了一类（class）对象–构造函数初始化对象组成的集合。类可以看做对象类型的子类型。 </p><ul><li>数组（Array）类</li><li>函数（Function）类 </li><li>日期（Date）类定义了代表日期的对象。</li><li>正则（RegExp）类定义了表示正则表达式的对象，强大通用的文本处理工具。</li><li>错误（Error）类定义了那些表示JavaScript程序中运行时错误和语法错误的对象。</li></ul><p>js中只有对象才能拥有方法。数字，字符串，布尔值也拥有自己的方法。只有null和undefined是无法拥有方法的值。</p><ul><li>可变（mutable）</li><li>不可变(immutable)<br>对象、数组、函数属于可变类型<br>字符串、数字、布尔值、null和undefined属于不可改变的类型。 </li></ul><p>js的变量是无类型的（untyped），变量可以被赋予任何类型的值，使用var关键字来声明（declare）变量。javascript采用语法作用域，不在任何函数内声明的变量称为全局变量（global variable）它在程序中任何地方都是可见的。</p><h2 id="3-1数字"><a href="#3-1数字" class="headerlink" title="3.1数字"></a>3.1数字</h2><p>数字均用浮点数值表示。采用64位浮点格式表示数字，实际的操作（数组索引，位操作符）则是基于32位整数。   </p><p><strong>数字直接量（numeric literal）</strong><br>十六进制 “0x”或“0X”   八进制  0开头   0377 ECMAScript 6的严格模式下，八进制直接量是明令禁止的   </p><p><strong>溢出（overflow）</strong><br>的数字上限（溢出），结果为一个特殊的无穷大（infinity）值，以Infinity表示。当负数的值超过了负数范围，结果为负无穷大以－Infinity表示。<br>无穷大值：基于它们的加、减、乘和除运算结果还是无穷大值（保留正负号）。<br><strong>下溢（underflow）</strong><br>当运算结果无限接近于零并比JavaScript能表示的最小值还小的时候发生的一种情形。返回0。负数发生下溢时，返回“负零”。</p><p><strong>被零整除</strong><br>被零整除并不报错：返回无穷大（Infinity）或负无穷大（－Infinity）。<br>零除以零运算结果也是一个非数字（not-a-number）值，用NaN表示。无穷大除以无穷大、给任意负数作开方运算或者算术运算符与不是数字或无法转换为数字的操作数一起使用时都将返回NaN。<br>NaN和任何值都不相等，包括自身。当且仅当x为NaN的时候，表达式x!=x的结果才为true。<br>函数isNaN()，如果参数是NaN或者是一个非数字值（比如字符串和对象），则返回true。<br>函数isFinite()，在参数不是NaN、Infinity或-Infinity的时候返回true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="literal">Infinity</span>/<span class="number">0</span>   <span class="comment">//Infinity</span></div><div class="line"><span class="number">0</span>/<span class="number">0</span>    <span class="comment">//NaN</span></div><div class="line"><span class="literal">Infinity</span>/<span class="literal">Infinity</span>    <span class="comment">//NaN</span></div><div class="line"><span class="built_in">Number</span>.MIN_VALUE/<span class="number">2</span>     <span class="comment">//下溢 0 </span></div><div class="line"></div><div class="line"><span class="literal">Infinity</span>==-<span class="literal">Infinity</span>  <span class="comment">//=&gt;false  非数值和任何值（包括自身）都不相等。</span></div></pre></td></tr></table></figure><p><strong>浮点数表示法精度</strong><br>二进制浮点数表示法并不能精确表示十进制的分数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">.3</span><span class="number">-.2</span>  <span class="comment">//=&gt;0.09999999999999998</span></div><div class="line"><span class="number">.2</span><span class="number">-.1</span>  <span class="comment">//=&gt;0.1</span></div></pre></td></tr></table></figure></p><h2 id="3-2-文本"><a href="#3-2-文本" class="headerlink" title="3.2 文本"></a>3.2 文本</h2><p>字符串（string）是一组由16位值组成的不可变的有序序列。JavaScript通过字符串类型来表示文本。字符串的长度（length）是其所含16位值的个数。空字符串（empty string）长度为0，JavaScript中并没有表示单个字符的“字符型”。</p><p>字符串是固定不变的，一些方法都返回新字符串，原字符串本身并没有发生改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ECMAScript 5中，字符串直接量可以拆分成数行，每行必须以反斜线（\）结束，反斜线和行结束符都不算是字符串直接量的内容。</span></div><div class="line"><span class="comment">//=&gt; "onelongline"</span></div><div class="line"><span class="string">"one\</span></div><div class="line">long\</div><div class="line">line"</div></pre></td></tr></table></figure><p><strong>转义字符(escape sequence)</strong><br>转义字符 含义<br>\o NUL字符(\u0000)<br>\b 退格符(\u0008)<br>\t 水平制表符(\u0009)<br>\n 换行符(\u000A)<br>\v 垂直制表符(\u000B)<br>\f 换页符(\u000C)<br>\r 回车符(\u000D)<br>\” 双引号(\u0022)<br>\’ 撇号或单引号(\u0027)<br>\ 反斜线(\u005C)<br>\xXX 由两位十六进制数XX指定的Latin-1字符<br>\uXXXX 由4位十六进制数XXXX指定的Unicode字符</p><h2 id="3-3-布尔值"><a href="#3-3-布尔值" class="headerlink" title="3.3 布尔值"></a>3.3 布尔值</h2><p>任意JavaScript的值都可以转换为布尔值。false和下面6个可以转换成false的值有时称做“假值”(falsy value）；所有其他值，包括所有对象（数组）都会转换成true，其他值称做“真值”(truthy value)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="literal">undefined</span></div><div class="line"><span class="literal">null</span></div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">-0</span></div><div class="line"><span class="literal">NaN</span></div><div class="line"><span class="string">""</span> <span class="comment">// 空字符串</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> == <span class="literal">null</span> )      <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> == <span class="literal">undefined</span> ) <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> == <span class="number">0</span> )         <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> == <span class="string">''</span> )        <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log( <span class="literal">false</span> == <span class="literal">NaN</span> )       <span class="comment">// false</span></div></pre></td></tr></table></figure><h2 id="3-4-null、undefined"><a href="#3-4-null、undefined" class="headerlink" title="3.4 null、undefined"></a>3.4 null、undefined</h2><p>两者不包含任何属性和方法。 <strong>变量、属性赋值、参数传入 推荐使用null.</strong><br>null是关键字，描述“空值”。null认为是一个特殊的对象值，含义是“非对象”。null是它自有类型的唯一一个成员，它可以表示数字、字符串和对象是“无值”的。</p><p>undefined(未定义的值)表示更深层次的“空值”。</p><ul><li>变量没有初始化</li><li>查询对象属性或数组元不存在</li><li>函数没有返回任何值，则返回undefined</li><li>引用没有提供实参的函数形参的值</li><li>undifined是这个类型的唯一成员</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span>(<span class="literal">null</span>);  <span class="comment">//=&gt; object</span></div><div class="line"><span class="keyword">typeof</span>(undifined); <span class="comment">//=&gt; undifined</span></div><div class="line"><span class="literal">null</span> == <span class="literal">undefined</span>;  <span class="comment">//=&gt; true</span></div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"></div><div class="line">## 3.5 全局对象（global object）</div><div class="line">当JavaScript解释器启动时将创建一个新的全局对象,并定义如下属性</div><div class="line">- 全局属性</div><div class="line">- 全局函数</div><div class="line">- 构造函数</div><div class="line">- 全局对象</div><div class="line"></div><div class="line">`<span class="string">``</span>javascript</div><div class="line"><span class="comment">//使用JavaScript关键字this来引用全局对象</span></div><div class="line"><span class="keyword">var</span> global = <span class="keyword">this</span>; <span class="comment">// 定义一个引用全局对象的全局变量</span></div></pre></td></tr></table></figure><h2 id="3-6-包装对象"><a href="#3-6-包装对象" class="headerlink" title="3.6 包装对象"></a>3.6 包装对象</h2><p>存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象(一种实现细节)。<br>只要引用了属性，JavaScript就会将字面量通过调用new String()／Number()／ Boolean()构造函数创建一个临时对象，这些方法的调用均是来自于这个临时对象。<br>一旦属性引用结束，这个新创建的对象就会销毁。<br>null和undefined没有包装对象：访问它们的属性会造成一个类型错误。   </p><p>“==”等于运算符将原始值和其包装对象视为相等，   === 全等运算符视为不等 </p><p>var s = “test”, n = 1, b = true;  // 一个字符串、数字和布尔值<br>//显示创建包装对象<br>var S = new String(s);   // 一个字符串对象<br>var N = new Number(n);   // 一个数值对象<br>var B = new Boolean(b);   // 一个布尔对象   </p><p>console.log( s == S );         // true<br>console.log( s === S );         // false<br>typeof(s);   //  “string”<br>typeof(S);   //  “object”     </p><h2 id="3-7-不可变的原始值和可变的对象引用"><a href="#3-7-不可变的原始值和可变的对象引用" class="headerlink" title="3.7 不可变的原始值和可变的对象引用"></a>3.7 不可变的原始值和可变的对象引用</h2><p>对象（包括数组和函数）称为引用类型（reference type）， 对象的比较均是引用的比较：当且仅当它们引用同一个基对象时，它们才相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, p = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</div><div class="line">o === p;     <span class="comment">// false</span></div><div class="line"><span class="keyword">var</span> a = [], b = [];</div><div class="line">a === b;     <span class="comment">// false</span></div></pre></td></tr></table></figure><h2 id="3-8-类型转换"><a href="#3-8-类型转换" class="headerlink" title="3.8 类型转换"></a>3.8 类型转换</h2><table><thead><tr><th>值/from</th><th>字符串/to</th><th>数字/to</th><th>布尔值/to</th><th>对象/to  </th></tr></thead><tbody><tr><td>undefined</td><td>“undefined”</td><td>NaN</td><td>false</td><td>throws TypeError </td></tr><tr><td>null</td><td>“null”</td><td>0</td><td>false</td><td>throws TypeError </td></tr><tr><td>true</td><td>“true”</td><td>1</td><td></td><td>new Boolean(true)</td></tr><tr><td>false</td><td>“false”</td><td>0</td><td></td><td>new Boolean(false)</td></tr><tr><td>“”(空字符串)</td><td></td><td>0</td><td>false</td><td>new String(“”) </td></tr><tr><td>“1.2”</td><td></td><td>1.2</td><td>true</td><td>new String(“1.2”) </td></tr><tr><td>“one”</td><td></td><td>NaN</td><td>true</td><td>new String(“one”) </td></tr><tr><td>0</td><td>“0”</td><td></td><td>false</td><td>new Number(0)</td></tr><tr><td>-0</td><td>“0”</td><td></td><td>false</td><td>new Number(-0)</td></tr><tr><td>NaN</td><td>“NaN”</td><td></td><td>false</td><td>new Number(NaN)</td></tr><tr><td>Infinity</td><td>“Infinity”</td><td></td><td>true</td><td>new Number(Infinity)</td></tr><tr><td>-Infinity</td><td>“-Infinity”</td><td></td><td>true</td><td>new Number(-Infinity)</td></tr><tr><td>1</td><td>“1”</td><td></td><td>true</td><td>new Number(1)</td></tr><tr><td>{}(任意对象)</td><td>明细</td><td>明细</td><td>true</td><td></td></tr><tr><td>[] (任意数组)</td><td>“”</td><td>0</td><td>true</td><td></td></tr><tr><td>[9] (1个数字元素)</td><td>“9”</td><td>9</td><td>true</td><td></td></tr><tr><td>[‘a’] (其他数组)</td><td>join()方法</td><td>NaN</td><td>true</td><td></td></tr><tr><td>function(){}(任意函数)</td><td>明细</td><td>NaN</td><td>true</td><td></td></tr></tbody></table><p><strong>转换和相等性</strong></p><p>== 在判断时进行了类型转换， 一个值转换为另一个值并不意味着两个值相等。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//undefined转换成false    </span></div><div class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">//false</span></div></pre></td></tr></table></figure><p><strong>显示类型转换</strong></p><p>最简单的方法就是使用Boolean()、Number()、String()或Object()函数。除了null或undefined之外的任何值都具有toString()方法，这个方法的执行结果通常和String()方法的返回结果一致。</p><ul><li>“+”运算符的一个操作数是字符串，将会把另外一个操作数转换为字符串。</li><li>一元“+”运算符将其操作数转换为数字。</li><li>一元“！”运算符将其操作数转换为布尔值并取反。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x + <span class="string">""</span>  <span class="comment">// String(x)</span></div><div class="line">+x  <span class="comment">// Number(x)  x-0</span></div><div class="line">!!x <span class="comment">// Boolean(x)</span></div></pre></td></tr></table></figure><p>toString()方法 可以接收表示转换基数（radix）的可选参数，如果不指定此参数，转换规则将是基于十进制。支持进制数（范围在2～36之间）</p><p><strong>parseInt()函数 parseFloat()函数（全局函数）</strong></p><p>如果字符串前缀是“0x”或者“0X”，parseInt()将其解释为十六进制数，方法会跳过任意数量的前导空格，尽可能解析更多数值字符，并忽略后面的内容。如果第一个非空格字符是非法的数字直接量，将最终返回NaN。<br>parseInt()可以接收第二个可选参数，这个参数指定数字转换的基数，合法的取值范围是2～36</p><h3 id="3-8-3对象转换为原始值"><a href="#3-8-3对象转换为原始值" class="headerlink" title="3.8.3对象转换为原始值"></a>3.8.3对象转换为原始值</h3><p>所有的对象（包括数组和函数）都转换为true。 适用于包装对象，<strong>new Boolean(false)是一个对象而不是原始值，它将转换为true。</strong></p><p>++只适用于本地对象（native object）++  对象继承了俩个转换方法：</p><p> <strong>1.toString()</strong></p><ul><li>默认的toString()方法返回  “[object Object]”</li><li>数组类（Array class）将每个数组元素转换为一个字符串，并在元素之间添加逗号后合并成结果字符串。</li><li>函数类（Function class）返回这个函数的实现定义的表示方式。</li><li>日期类（Date class）返回了一个可读的（可被JavaScript解析的）日期和时间字符串。</li><li>RegExp类（RegExp class）将RegExp对象转换为表示正则表达式直接量的字符串。</li></ul><p><strong>2.valueOf()</strong><br>如果存在任意原始值，它就默认将对象转换为表示它的原始值。<br>对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。</p><ul><li>数组、函数和正则表达式 返回对象本身。</li><li>日期类 返回它的一个内部表示：1970年1月1日以来的毫秒数。</li></ul><h4 id="步骤：对象到字符串（object-to-string）"><a href="#步骤：对象到字符串（object-to-string）" class="headerlink" title="步骤：对象到字符串（object-to-string）"></a>步骤：对象到字符串（object-to-string）</h4><ol><li>如果对象具有toString()方法，则调用这个方法。如果它返回一个<strong>原始值</strong>，JavaScript将这个值转换为字符串(如果本身不是字符串的话)，并返回这个字符串结果。</li><li>如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么JavaScript会调用valueOf()方法。如果存在这个方法，则JavaScript调用它。如果返回值是原始值，JavaScript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果。</li><li>否则，JavaScript无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常。</li></ol><h4 id="步骤：对象到数字（object-to-number）"><a href="#步骤：对象到数字（object-to-number）" class="headerlink" title="步骤：对象到数字（object-to-number）"></a>步骤：对象到数字（object-to-number）</h4><ol><li>如果对象具有valueOf()方法，后者返回一个原始值，则JavaScript将这个原始值转换为数字并返回这个数字。</li><li>否则，如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回。</li><li>否则，JavaScript抛出一个类型错误异常。</li></ol><p>数组是对象，调用valueOf方法无法返回原始值，所以调用toString().空数组转换成空字符串，然后空字符串转化成0;含一个元素的数组转换为字符串结果，然后转化为数值。</p><p><strong>运算符</strong></p><p>“+” 可以数字和字符串连接操作，若果一个操作数时对象，对象转为原始值。<br>“==” 原始值和对象比较，对象转换为原始值进行比较。</p><p>对象到原始值的转换：非日期对象先尝试调用valueOf()，然后调用toString()返回的原始值将被直接使用，不会被强制转换为数字或字符串；日期对象直接转换成字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="string">"2"</span>+<span class="number">3</span>   <span class="comment">//"23"</span></div><div class="line"><span class="number">2</span>+[<span class="number">2</span>]   <span class="comment">//"22"</span></div><div class="line"><span class="number">2</span>+[<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//"22,3"</span></div><div class="line"><span class="number">2</span>+[]    <span class="comment">//"2"</span></div><div class="line">[<span class="number">2</span>]==<span class="number">2</span>  <span class="comment">//true</span></div><div class="line">[<span class="number">2</span>]==<span class="string">'2'</span> <span class="comment">//true</span></div><div class="line">[]==<span class="string">''</span>  <span class="comment">//true</span></div><div class="line"> </div><div class="line"><span class="comment">//日期对象</span></div><div class="line"><span class="keyword">var</span> now=<span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line"><span class="keyword">typeof</span>(now+<span class="number">1</span>)   <span class="comment">//"string"</span></div><div class="line"><span class="keyword">typeof</span>(now<span class="number">-1</span>)   <span class="comment">//"number"</span></div><div class="line">now==now.toString()  <span class="comment">//true</span></div><div class="line">now&gt;(now<span class="number">-1</span>)   <span class="comment">//true</span></div></pre></td></tr></table></figure><h2 id="3-10-变量作用域"><a href="#3-10-变量作用域" class="headerlink" title="3.10 变量作用域"></a>3.10 变量作用域</h2><p>变量值初始值时 undefined. 没有块级作用域（block scope）。 函数作用域（function scope）：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。      </p><p><strong>声明提前（hoisting）</strong><br>函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部.  变量声明放在函数体顶部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"undefined"，而不是"global"</span></div><div class="line"> <span class="keyword">var</span> scope = <span class="string">"local"</span>; <span class="comment">// 变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的</span></div><div class="line"> <span class="built_in">console</span>.log(scope);  <span class="comment">// 输出"local"</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//等价于</span></div><div class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="keyword">var</span> scope;</div><div class="line"> <span class="built_in">console</span>.log(scope);  </div><div class="line"> scope = <span class="string">"local"</span>;  </div><div class="line"> <span class="built_in">console</span>.log(scope);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong> 全局变量（global variable） </strong></p><p>当声明一个JavaScript全局变量时，实际上是定义了全局对象的一个属性。</p><ul><li>当使用var声明一个变量时，创建的这个属性是不可配置的，无法通过delete运算符删除。</li><li>在非严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量，是可配置属性，可以删除。</li></ul><p><strong> 作用域链（scope chain）</strong></p><p>JavaScript是基于词法作用域（lexical scoping）的语言：通过阅读包含变量定义在内的数行源码就能知道变量的作用域。</p><p>当JavaScript需要查找变量x的值的过程称做“变量解析”（variable resolution）</p><p>在最顶层代码中（也就是不包含在任何函数定义内的代码），作用域链由一个全局对象组成。</p><p>在不包含嵌套的函数体内，作用域链上有两个对象，<br>第一个是定义函数参数和局部变量的对象，<br>第二个是全局对象。<br>在一个嵌套的函数体内，作用域链上至少有三个对象。</p><blockquote><p>当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。<br>对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别——在每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。</p></blockquote>]]></content>
    
    <summary type="html">
    
      二刷，扫坑!
    
    </summary>
    
      <category term="FrontEnd" scheme="http://anduril.cn/categories/FrontEnd/"/>
    
    
      <category term="JavaScript" scheme="http://anduril.cn/tags/JavaScript/"/>
    
      <category term="Reading" scheme="http://anduril.cn/tags/Reading/"/>
    
  </entry>
  
  <entry>
    <title>当我们谈论旅行时我们在谈论什么</title>
    <link href="http://anduril.cn/2017/06/19/what-travel-means-to-us/"/>
    <id>http://anduril.cn/2017/06/19/what-travel-means-to-us/</id>
    <published>2017-06-18T17:17:56.000Z</published>
    <updated>2017-06-19T14:29:20.000Z</updated>
    
    <content type="html"><![CDATA[<span itemprop="image" itemscope="" itemtype="http://schema.org/ImageObject"><img itemprop="url image" src="/images/what-travel-means-to-us-header.jpg" class="full-image"><meta itemprop="width" content="auto"><meta itemprop="height" content="auto"></span><blockquote class="blockquote-center"><p> You can either travel or read, but either your body or soul must be on the way.<br><strong>Roman Holiday</strong> </p></blockquote><h2 id="0x01-旅行意味着什么"><a href="#0x01-旅行意味着什么" class="headerlink" title="0x01.旅行意味着什么"></a>0x01.旅行意味着什么</h2><p>“要么读书，要么旅行，身体和灵魂总有一个在路上”，诚然这种生活境界很难做到。幸运的是，我们的出行随着交通的发展更加便捷。“但是自问为什么要去旅行呢？或者我们为了什么而去旅行？”</p><p>我喜欢喜欢深入到大自然，游览大好河山，陶冶情操。在旅行中，抛开生活工作中的电话和邮件，忘掉一切，你就是你自己，没有任何职位角色，聚焦于眼前的目标–攀爬一座山头或是骑行一段路程，努力的与时间赛跑，与周围的环境融为一体，即使身体的疲劳酸痛也不能阻止精神的自由翱翔！这就是所谓的“旅行的乐趣”。</p><p>每个人的生活就是一个圈子，时间久了我们对人物都会由熟悉到嫌弃，一成不变的生活方式是很难让人满意。在旅行的路上我们可以结识志同道合的朋友，打开你的视野和思维，体验不同风俗文化间的差异，一次短暂的消失，让你不会对生活感到疲惫。</p><p>这种角色的互换充满了欢愉，却又如夜空中烟花般短暂美丽，却仍是生活这篇章跳动的乐符。</p><h2 id="0x02-阅读意味着什么"><a href="#0x02-阅读意味着什么" class="headerlink" title="0x02.阅读意味着什么"></a>0x02.阅读意味着什么</h2><p>旅行中我会带个kindle和一本纸质书，在文字地伴随下帮你度过路途中枯燥和无聊。</p><p>旅行相较于阅读，感官更加直接，画面感更强，所以我比较喜欢旅行。即使我喜欢旅行，花在阅读的时间更多，因为后者消耗更少的金钱和精力，所谓的投资回报率最高。</p><p>在这个快节奏的时代，知识付费横飞，我为什么还要一句句的阅读思考呢？不是有“成品”销售吗？当然你可以为此付些智商税，别人也拦不住。</p><p>当下的我们每天沉浸在微博、朋友圈、知乎，看着一些碎片化的“知识”而一知半解；缺乏阅读积累的思考，只是对少数话语的迷信；缺乏思考的阅读，只是对已有话语的模仿，其实这是“博识的无知”。杨绛先生的“想法太多，读书太少”描述最为贴切。</p><p>聪明的读者会知道自己没有什么，自己需要学习什么。通过系统阅读可以花最少的成本来构建自己的知识架构，可以让你在生活、工作中快速的成长，最重要的时让你学会自主的思考和独立的人格，在生活中不会随波而流！</p><h2 id="0x03-追寻远方"><a href="#0x03-追寻远方" class="headerlink" title="0x03.追寻远方"></a>0x03.追寻远方</h2><p>我热爱阅读和旅行，我热爱生活！是因为我从之感受生活的希望，那么多美好的事物，生活展示出那么多可能性。世界如此美好，我应为只奋斗！我能有什么理由放弃呢！</p><p>读万卷书，行万里路！</p><p>共勉之。</p><p>– 写于苏州</p>]]></content>
    
    <summary type="html">
    
      要么读书，要么旅行，身体和灵魂总有一个在路上!
    
    </summary>
    
      <category term="Life" scheme="http://anduril.cn/categories/Life/"/>
    
    
      <category term="Reading" scheme="http://anduril.cn/tags/Reading/"/>
    
      <category term="Travel" scheme="http://anduril.cn/tags/Travel/"/>
    
  </entry>
  
  <entry>
    <title>thoughtworks读书雷达计划</title>
    <link href="http://anduril.cn/2016/04/27/thoughtworks-reading-rader-plan/"/>
    <id>http://anduril.cn/2016/04/27/thoughtworks-reading-rader-plan/</id>
    <published>2016-04-27T12:00:00.000Z</published>
    <updated>2017-06-19T12:34:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>纸上得来终觉浅，绝知此事要躬行！</p><p>系统的进行阅读，然后尝试实践！计划长期有效！贴出豆瓣书单！</p><h2 id="Coding-Practice（编程实践）"><a href="#Coding-Practice（编程实践）" class="headerlink" title="Coding Practice（编程实践）"></a>Coding Practice（编程实践）</h2><p><a href="https://www.douban.com/doulist/44364662/" target="_blank" rel="external">豆单</a>    </p><h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><blockquote><p>Clean Code《代码整洁之道》<br>Pragmatic Unit Testing《单元测试之道》<br>The Productive Programmer《卓有成效的程序员》<br>Test-Driven Development By Example《测试驱动开发》<br>Clean Coder《程序员的职业修养》<br>The Art of Readable Code《编写可读代码的艺术》</p></blockquote><h3 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h3><blockquote><p>Refactoring To Patterns《重构与模式》<br>Implementation Patterns《实现模式》<br>Code Complete《代码大全》<br>The Pragmatic Programmer《程序员修炼之道》</p></blockquote><h3 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h3><blockquote><p>Structure and Interpretation of Computer Programs《计算机程序的构造和解释》<br>Working Effectively with Legacy Code《修改代码的艺术》</p></blockquote><h2 id="Architecture-amp-Design（架构与设计）"><a href="#Architecture-amp-Design（架构与设计）" class="headerlink" title="Architecture &amp; Design（架构与设计）"></a>Architecture &amp; Design（架构与设计）</h2><h3 id="基础篇-1"><a href="#基础篇-1" class="headerlink" title="基础篇"></a>基础篇</h3><blockquote><p>Agile Software Development 《敏捷软件开发：原则、实践与模式》<br>Head First Design Patterns《深入浅出设计模式》<br>Design Patterns 《设计模式》</p></blockquote><h3 id="进阶篇-1"><a href="#进阶篇-1" class="headerlink" title="进阶篇"></a>进阶篇</h3><blockquote><p>The Art of UNIX Programming 《Unix编程艺术》<br>Practical API Design 《框架设计的艺术》<br>Domain Specific Languages 《领域特定语言》<br>Patterns of Enterprise Application Architecture 《企业应用架构模式》</p></blockquote><h3 id="高级篇-1"><a href="#高级篇-1" class="headerlink" title="高级篇"></a>高级篇</h3><blockquote><p>Release It<br>Domain-Driven Design 《领域驱动设计》<br>Enterprise Integration Patterns《企业集成模式》<br>Beautiful Architecture《架构之美》<br>Pattern-Oriented Software Architecture《面向模式的软件架构》</p></blockquote><h2 id="Methodology（方法学）"><a href="#Methodology（方法学）" class="headerlink" title="Methodology（方法学）"></a>Methodology（方法学）</h2><h3 id="基础篇-2"><a href="#基础篇-2" class="headerlink" title="基础篇"></a>基础篇</h3><blockquote><p>User Stories Applied《用户故事与敏捷方法》<br>The Gold Mine《金矿》<br>Scrum and XP From the Trenches《硝烟中的Scrum和XP》<br>Continuous Integration《持续集成》<br>Extreme Programming Explained《解析极限编程》</p></blockquote><h3 id="进阶篇-2"><a href="#进阶篇-2" class="headerlink" title="进阶篇"></a>进阶篇</h3><blockquote><p>Lean Thinking《精益思想》<br>Continuous Delivery《持续交付》<br>How Google Tests Software<br>Agile Testing<br>Extreme Programming Refactored《重构极限编程》</p></blockquote><h3 id="高级篇-2"><a href="#高级篇-2" class="headerlink" title="高级篇"></a>高级篇</h3><blockquote><p>Specification By Example</p></blockquote><h2 id="Thought-amp-Leadership（思想与领导力）"><a href="#Thought-amp-Leadership（思想与领导力）" class="headerlink" title="Thought &amp; Leadership（思想与领导力）"></a>Thought &amp; Leadership（思想与领导力）</h2><h3 id="基础篇-3"><a href="#基础篇-3" class="headerlink" title="基础篇"></a>基础篇</h3><blockquote><p>The Effective Executive《卓有成效的管理者》<br>Are Your Lights On?《你的灯亮着吗》<br>Becoming A Technical Leader《成为技术领导者》</p></blockquote><h3 id="进阶篇-3"><a href="#进阶篇-3" class="headerlink" title="进阶篇"></a>进阶篇</h3><blockquote><p>The Fifth Discipline《第五项修炼》<br>The Design Of Business<br>Management 3.0《管理3.0：培养和提升敏捷领导力》<br>Presentation To Win<br>The McKinsey Way《麦肯锡方法》</p></blockquote><h3 id="高级篇-3"><a href="#高级篇-3" class="headerlink" title="高级篇"></a>高级篇</h3><blockquote><p>Thinking, Fast and Slow《思考快与慢》</p></blockquote><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="http://agiledon.github.io/blog/2013/04/17/thoughtworks-developer-reading-radar/" target="_blank" rel="external">http://agiledon.github.io/blog/2013/04/17/thoughtworks-developer-reading-radar/</a></p>]]></content>
    
    <summary type="html">
    
      想法太多，读书太少!
    
    </summary>
    
      <category term="Programmer" scheme="http://anduril.cn/categories/Programmer/"/>
    
    
      <category term="Reading" scheme="http://anduril.cn/tags/Reading/"/>
    
  </entry>
  
</feed>
